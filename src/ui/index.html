<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>PQ Reps Audio Generator</title>
    <style>
      :root {
        --color-primary-yellow: #ffc524;
        --color-primary-yellow-light: #ffe28a;
        --color-primary-yellow-dark: #e0a800;
        --color-primary-orange: #ff8e4f;
        --color-primary-orange-light: #ffc1a1;
        --color-primary-orange-dark: #e66f2e;
        --color-primary-blue: #82e6e6;
        --color-primary-blue-light: #cff5f5;
        --color-primary-blue-dark: #4fc6c6;
        --color-primary-green: #63d9a0;
        --color-primary-green-light: #b8eed5;
        --color-primary-green-dark: #2fbf7f;
        --color-neutral-white: #ffffff;
        --color-neutral-gray: #f8f8f8;
        --color-neutral-gray-mid: #e5e5e5;
        --color-neutral-black-30: #bfbfbf;
        --color-neutral-black: #000000;
        --radius-pill: 999px;
        --radius-card: 18px;
        --radius-panel: 12px;
        --font-size-xs: 0.8rem;
        --font-size-sm: 0.9rem;
        --font-size-md: 1rem;
        --font-size-lg: 1.2rem;
        --font-size-xl: 2rem;
        --space-1: 0.25rem;
        --space-2: 0.5rem;
        --space-3: 0.75rem;
        --space-4: 1rem;
        --space-5: 1.5rem;
        --space-6: 2rem;
      }
      body {
        font-family: "Inter", system-ui, sans-serif;
        background: var(--color-neutral-gray-mid);
        margin: 0;
        padding: var(--space-6);
        color: var(--color-neutral-black);
        font-size: var(--font-size-md);
        line-height: 1.6;
      }
      main {
        max-width: 720px;
        margin: 0 auto;
        background: var(--color-neutral-white);
        padding: var(--space-6);
        border-radius: 20px;
        box-shadow: 0 18px 45px rgba(0, 0, 0, 0.08);
      }
      h1 {
        margin: 0 0 var(--space-2);
        font-size: var(--font-size-xl);
        line-height: 1.2;
      }
      p {
        margin: 0 0 var(--space-3);
      }
      .version {
        margin: 0 0 var(--space-3);
        color: rgba(0, 0, 0, 0.7);
        font-size: var(--font-size-sm);
      }
      form {
        display: grid;
        gap: var(--space-5);
      }
      #panel-customize {
        display: grid;
        gap: var(--space-4);
      }
      #panel-customize[hidden] {
        display: none;
      }
      #panel-customize label {
        margin: 0;
      }
      label {
        display: grid;
        gap: var(--space-2);
        font-weight: 600;
        font-size: var(--font-size-md);
      }
      input {
        padding: var(--space-3);
        border-radius: 10px;
        border: 1px solid var(--color-neutral-black-30);
        font-size: var(--font-size-md);
        background: var(--color-neutral-gray);
      }
      .pill-group {
        display: flex;
        flex-wrap: wrap;
        gap: var(--space-2);
      }
      .pill-option {
        position: relative;
      }
      .pill-option input {
        position: absolute;
        opacity: 0;
        pointer-events: none;
      }
      .pill {
        display: inline-flex;
        align-items: center;
        padding: 0.55rem 1.1rem;
        border-radius: var(--radius-pill);
        border: 1px solid var(--color-primary-orange);
        background: var(--color-neutral-white);
        font-weight: 600;
        cursor: pointer;
        transition: all 0.15s ease;
        font-size: var(--font-size-md);
      }
      .pill-option input:checked + .pill {
        background: var(--color-primary-orange);
        border-color: var(--color-primary-orange);
        color: var(--color-neutral-black);
      }
      .pill-option input:focus-visible + .pill {
        outline: 2px solid var(--color-primary-blue);
        outline-offset: 2px;
      }
      .pill-option input:disabled + .pill {
        opacity: 0.5;
        cursor: not-allowed;
      }
      .section-toggle {
        display: flex;
        flex-wrap: wrap;
        gap: var(--space-3);
        border-bottom: 1px solid var(--color-primary-orange);
      }
      .section-toggle button {
        padding: 0.55rem 1rem;
        border-radius: 8px 8px 0 0;
        border: 1px solid transparent;
        border-bottom: 3px solid transparent;
        background: transparent;
        color: rgba(0, 0, 0, 0.75);
        font-weight: 600;
        cursor: pointer;
        font-size: var(--font-size-md);
        transition: all 0.15s ease;
      }
      .section-toggle button.is-active {
        background: var(--color-neutral-white);
        border-bottom-color: var(--color-primary-orange-dark);
        color: var(--color-neutral-black);
      }
      .section-toggle [role="tab"]:focus-visible {
        outline: 2px solid var(--color-primary-blue);
        outline-offset: 2px;
      }
      .section-toggle [role="tab"]:focus-visible {
        outline: 2px solid var(--color-primary-blue);
        outline-offset: 2px;
      }
      .options-drawer {
        border: 1px solid var(--color-neutral-black-30);
        border-radius: var(--radius-panel);
        padding: var(--space-3) var(--space-4);
        background: var(--color-neutral-white);
      }
      .options-drawer summary {
        cursor: pointer;
        font-weight: 600;
        list-style: none;
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: var(--space-2);
        padding: var(--space-2) var(--space-3);
        border-radius: 10px;
        background: var(--color-neutral-white);
        border: none;
      }
      .options-drawer summary::-webkit-details-marker {
        display: none;
      }
      .options-content {
        display: grid;
        gap: var(--space-4);
        margin-top: var(--space-4);
      }
      .scenario-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(220px, 1fr));
        gap: var(--space-3);
        margin-bottom: var(--space-4);
      }
      .scenario-card {
        text-align: left;
        border-radius: var(--radius-card);
        border: 1px solid var(--color-primary-orange);
        padding: var(--space-4);
        background: #ffffff;
        color: var(--color-neutral-black);
        cursor: pointer;
        transition: transform 0.15s ease, border 0.15s ease;
      }
      .scenario-card:hover {
        transform: translateY(-1px);
      }
      .scenario-card.is-selected {
        border-color: var(--color-primary-orange);
        background: var(--color-primary-orange);
      }
      .scenario-title {
        font-weight: 700;
        margin-bottom: var(--space-1);
        font-size: var(--font-size-md);
      }
      .scenario-meta {
        font-size: var(--font-size-sm);
        line-height: 1.5;
        color: rgba(0, 0, 0, 0.7);
      }
      button {
        padding: 0.85rem 1.6rem;
        background: var(--color-neutral-black);
        color: var(--color-neutral-gray);
        border: none;
        border-radius: var(--radius-pill);
        font-weight: 600;
        cursor: pointer;
        font-size: var(--font-size-md);
        line-height: 1.1;
      }
      .button-large {
        padding: 1.1rem 2.4rem;
        font-size: var(--font-size-lg);
        font-weight: 700;
      }
      .button-primary {
        background: var(--color-neutral-black);
        color: var(--color-neutral-gray);
      }
      .button-secondary {
        background: var(--color-neutral-gray-mid);
        color: var(--color-neutral-black);
      }
      button[disabled] {
        cursor: not-allowed;
        background: var(--color-neutral-gray-mid);
        color: var(--color-neutral-black);
      }
      .status-panel {
        margin-top: var(--space-5);
        padding: var(--space-4);
        border-radius: var(--radius-panel);
        background: var(--color-primary-blue-light);
        border: 1px solid var(--color-primary-blue);
        display: grid;
        gap: var(--space-2);
      }
      .status-panel[hidden] {
        display: none;
      }
      .status-row {
        display: flex;
        align-items: center;
        gap: 0.75rem;
      }
      .spinner {
        width: 18px;
        height: 18px;
        border-radius: 50%;
        border: 3px solid var(--color-primary-blue-light);
        border-top-color: var(--color-primary-blue-dark);
        animation: spin 0.9s linear infinite;
      }
      .spinner[hidden] {
        display: none;
      }
      .status {
        margin: 0;
        color: var(--color-neutral-black);
        font-weight: 600;
      }
      .progress-list {
        margin: var(--space-2) 0 0;
        padding-left: var(--space-5);
        color: var(--color-neutral-black);
      }
      .progress-list li {
        margin: var(--space-1) 0;
      }
      .error {
        background: var(--color-primary-orange-light);
        color: var(--color-neutral-black);
        padding: var(--space-4);
        border-radius: 10px;
      }
      .result {
        margin-top: var(--space-6);
        background: var(--color-neutral-gray);
        padding: var(--space-5);
        border-radius: var(--radius-panel);
      }
      .debug-prompt {
        margin-top: var(--space-5);
        background: var(--color-neutral-black);
        color: var(--color-neutral-gray);
        padding: var(--space-4);
        border-radius: 10px;
        white-space: pre-wrap;
        word-break: break-word;
      }
      .hint {
        font-weight: 400;
        color: var(--color-neutral-black);
        font-size: var(--font-size-sm);
      }
      .download-link {
        display: inline-flex;
        font-weight: 600;
        color: var(--color-neutral-black);
        text-decoration: none;
      }
      .download-link.is-disabled {
        color: var(--color-neutral-black-30);
        pointer-events: none;
      }
      .download-links {
        display: flex;
        align-items: center;
        gap: 0.5rem;
        margin-top: 0.75rem;
      }
      .download-separator {
        color: var(--color-neutral-black);
      }
      .option-hint {
        font-weight: 400;
        color: var(--color-neutral-black);
        font-size: var(--font-size-sm);
      }
      .info-icon {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        width: 18px;
        height: 18px;
        border-radius: var(--radius-pill);
        border: 1px solid var(--color-neutral-black-30);
        color: var(--color-neutral-black);
        font-size: var(--font-size-xs);
        font-weight: 600;
        cursor: help;
        position: relative;
      }
      .info-icon::after {
        content: attr(data-tooltip);
        position: absolute;
        bottom: calc(100% + 8px);
        left: 50%;
        transform: translateX(-50%);
        background: var(--color-neutral-black);
        color: var(--color-neutral-gray);
        padding: 0.4rem 0.6rem;
        border-radius: 10px;
        font-size: var(--font-size-xs);
        font-weight: 500;
        white-space: nowrap;
        opacity: 0;
        pointer-events: none;
        transition: opacity 0.15s ease;
        z-index: 10;
      }
      .info-icon:hover::after,
      .info-icon:focus-visible::after {
        opacity: 1;
      }
      .voice-preview {
        display: flex;
        flex-wrap: wrap;
        align-items: center;
        gap: var(--space-3);
      }
      .voice-preview button {
        padding: 0.4rem 0.85rem;
        border-radius: var(--radius-pill);
        border: 1px solid var(--color-neutral-black-30);
        background: var(--color-neutral-gray);
        color: var(--color-neutral-black);
        font-weight: 500;
        line-height: 1.2;
        font-size: var(--font-size-sm);
      }
      .voice-preview button[disabled] {
        background: var(--color-primary-green-light);
        color: var(--color-neutral-black);
      }
      .footer {
        margin-top: var(--space-6);
        padding-top: var(--space-4);
        border-top: 1px solid var(--color-neutral-gray-mid);
        color: var(--color-neutral-black);
        font-size: var(--font-size-sm);
        line-height: 1.5;
        display: grid;
        grid-template-columns: repeat(3, minmax(0, 1fr));
        gap: var(--space-3);
        align-items: start;
      }
      .footer-text {
        grid-column: 1 / span 2;
        margin: 0;
      }
      .footer-locale {
        display: flex;
        align-items: center;
        gap: var(--space-2);
        flex-wrap: wrap;
        justify-content: flex-end;
      }
      .footer-locale-icon {
        color: var(--color-neutral-black);
      }
      .footer-locale-label {
        font-weight: 600;
      }
      .footer-locale select {
        padding: 0.35rem 0.7rem;
        border-radius: var(--radius-pill);
        border: 1px solid var(--color-neutral-black-30);
        background: var(--color-neutral-gray);
        color: var(--color-neutral-black);
        font-size: var(--font-size-sm);
      }
      @keyframes spin {
        to {
          transform: rotate(360deg);
        }
      }
    </style>
  </head>
  <body>
    <main>
      <h1 id="app-title">PQ Reps Audio Generator</h1>
      <p id="app-version" class="version">Version: loading...</p>
      <p id="app-description">Choose the type of PQ Reps you'd like to practice.</p>
      <p id="app-ai-notice">Audio is AI-generated.</p>

      <form id="generator-form">
        <input type="hidden" name="scenarioId" id="scenario-id" value="" />

        <div class="section-toggle" id="section-tablist" role="tablist" aria-label="">
          <button
            type="button"
            id="quick-access-toggle"
            class="is-active"
            role="tab"
            aria-selected="true"
            aria-controls="panel-quick"
            tabindex="0"
            data-i18n="form.quick_access"
          >
            Quick access
          </button>
          <button
            type="button"
            id="customize-toggle"
            role="tab"
            aria-selected="false"
            aria-controls="panel-customize"
            tabindex="-1"
            data-i18n="form.customize"
          >
            Customize
          </button>
        </div>

        <div id="panel-quick" role="tabpanel" aria-labelledby="quick-access-toggle">
          <div class="scenario-grid">
            <button
              type="button"
              class="scenario-card"
              data-scenario-id="calm_me_now"
              data-practice-type="still_eyes_open"
              data-focus="touch"
              data-duration-minutes="1"
            >
              <div class="scenario-title" data-i18n="scenario.calm_me_now">Calm me now</div>
              <div class="scenario-meta">
                <span data-i18n="form.practice_type.still_eyes_open">Still (Eyes open)</span> ‚Ä¢
                <span data-i18n="form.focus.touch">Touch</span> ‚Ä¢
                <span data-duration="1">1 minute</span>
              </div>
            </button>
            <button
              type="button"
              class="scenario-card"
              data-scenario-id="get_present_for_meeting"
              data-practice-type="still_eyes_open"
              data-focus="touch"
              data-duration-minutes="1"
            >
              <div class="scenario-title" data-i18n="scenario.get_present_for_meeting">
                Get present for a meeting
              </div>
              <div class="scenario-meta">
                <span data-i18n="form.practice_type.still_eyes_open">Still (Eyes open)</span> ‚Ä¢
                <span data-i18n="form.focus.touch">Touch</span> ‚Ä¢
                <span data-duration="1">1 minute</span>
              </div>
            </button>
            <button
              type="button"
              class="scenario-card"
              data-scenario-id="start_the_thing_im_avoiding"
              data-practice-type="moving"
              data-focus="touch"
              data-duration-minutes="1"
            >
              <div class="scenario-title" data-i18n="scenario.start_the_thing_im_avoiding">
                Start the thing I‚Äôm avoiding
              </div>
              <div class="scenario-meta">
                <span data-i18n="form.practice_type.moving">Moving</span> ‚Ä¢
                <span data-i18n="form.focus.touch">Touch</span> ‚Ä¢
                <span data-duration="1">1 minute</span>
              </div>
            </button>
            <button
              type="button"
              class="scenario-card"
              data-scenario-id="prepare_for_a_tough_conversation"
              data-practice-type="still_eyes_open"
              data-focus="sight"
              data-duration-minutes="2"
            >
              <div class="scenario-title" data-i18n="scenario.prepare_for_a_tough_conversation">
                Prepare for a tough conversation
              </div>
              <div class="scenario-meta">
                <span data-i18n="form.practice_type.still_eyes_open">Still (Eyes open)</span> ‚Ä¢
                <span data-i18n="form.focus.sight">Sight</span> ‚Ä¢
                <span data-duration="2">2 minutes</span>
              </div>
            </button>
            <button
              type="button"
              class="scenario-card"
              data-scenario-id="reset_after_feedback"
              data-practice-type="labeling"
              data-focus="hearing"
              data-duration-minutes="2"
            >
              <div class="scenario-title" data-i18n="scenario.reset_after_feedback">
                Reset after feedback
              </div>
              <div class="scenario-meta">
                <span data-i18n="form.practice_type.labeling">Labeling</span> ‚Ä¢
                <span data-i18n="form.focus.hearing">Hearing</span> ‚Ä¢
                <span data-duration="2">2 minutes</span>
              </div>
            </button>
            <button
              type="button"
              class="scenario-card"
              data-scenario-id="wind_down_for_sleep"
              data-practice-type="still_eyes_closed"
              data-focus="breath"
              data-duration-minutes="5"
            >
              <div class="scenario-title" data-i18n="scenario.wind_down_for_sleep">
                Wind down for sleep
              </div>
              <div class="scenario-meta">
                <span data-i18n="form.practice_type.still_eyes_closed">Still (Eyes closed)</span> ‚Ä¢
                <span data-i18n="form.focus.breath">Breath</span> ‚Ä¢
                <span data-duration="5">5 minutes</span>
              </div>
            </button>
            <button
              type="button"
              class="scenario-card"
              data-scenario-id="daily_deep_reset"
              data-practice-type="still_eyes_closed"
              data-focus="touch"
              data-duration-minutes="12"
            >
              <div class="scenario-title" data-i18n="scenario.daily_deep_reset">
                Daily deep reset
              </div>
              <div class="scenario-meta">
                <span data-i18n="form.practice_type.still_eyes_closed">Still (Eyes closed)</span> ‚Ä¢
                <span data-i18n="form.focus.touch">Touch</span> ‚Ä¢
                <span data-duration="12">12 minutes</span>
              </div>
            </button>
          </div>
        </div>

        <div id="panel-customize" role="tabpanel" aria-labelledby="customize-toggle" hidden>
        <label>
          <span id="label-practice-type">Practice type</span>
          <div class="pill-group" role="radiogroup" aria-label="" id="group-practice-type">
            <label class="pill-option">
              <input type="radio" name="practiceType" value="still_eyes_closed" checked required />
              <span class="pill" data-i18n="form.practice_type.still_eyes_closed">Still (Eyes closed)</span>
            </label>
            <label class="pill-option">
              <input type="radio" name="practiceType" value="still_eyes_open" />
              <span class="pill" data-i18n="form.practice_type.still_eyes_open">Still (Eyes open)</span>
            </label>
            <label class="pill-option">
              <input type="radio" name="practiceType" value="moving" />
              <span class="pill" data-i18n="form.practice_type.moving">Moving</span>
            </label>
            <label class="pill-option">
              <input type="radio" name="practiceType" value="labeling" />
              <span class="pill" data-i18n="form.practice_type.labeling">Labeling</span>
            </label>
          </div>
        </label>

        <label>
          <span id="label-focus">Focus</span>
          <div class="pill-group" role="radiogroup" aria-label="" id="group-focus">
            <label class="pill-option">
              <input type="radio" name="focus" value="touch" checked required />
              <span class="pill" data-i18n="form.focus.touch">Touch</span>
            </label>
            <label class="pill-option">
              <input type="radio" name="focus" value="hearing" />
              <span class="pill" data-i18n="form.focus.hearing">Hearing</span>
            </label>
            <label class="pill-option">
              <input type="radio" name="focus" value="sight" />
              <span class="pill" data-i18n="form.focus.sight">Sight</span>
            </label>
            <label class="pill-option">
              <input type="radio" name="focus" value="breath" />
              <span class="pill" data-i18n="form.focus.breath">Breath</span>
            </label>
          </div>
        </label>

        <label>
          <span id="label-duration">Duration</span>
          <div class="pill-group" role="radiogroup" aria-label="" id="group-duration">
            <label class="pill-option">
              <input type="radio" name="durationMinutes" value="1" checked required />
              <span class="pill" data-duration="1">1 minute</span>
            </label>
            <label class="pill-option">
              <input type="radio" name="durationMinutes" value="2" />
              <span class="pill" data-duration="2">2 minutes</span>
            </label>
            <label class="pill-option">
              <input type="radio" name="durationMinutes" value="5" />
              <span class="pill" data-duration="5">5 minutes</span>
            </label>
            <label class="pill-option">
              <input type="radio" name="durationMinutes" value="12" />
              <span class="pill" data-duration="12">12 minutes</span>
            </label>
          </div>
        </label>

        <div id="dev-controls" hidden>
          <label>
            <span id="label-tts-newline">TTS newline pause (seconds)</span>
            <input type="number" name="ttsNewlinePauseSeconds" min="0" step="0.5" value="1.5" />
          </label>

          <label>
            <span id="label-debug-tts">Debug TTS prompt</span>
            <span class="hint" id="debug-tts-help">Include the raw TTS payload for OpenAI playground testing.</span>
            <input type="checkbox" name="debugTtsPrompt" />
          </label>
        </div>

        </div>

        <details class="options-drawer">
          <summary id="options-summary" data-i18n="form.options">
            Options
            <span aria-hidden="true">‚ñæ</span>
          </summary>
          <div class="options-content">
            <label>
              <span id="label-language">Language</span>
              <div class="pill-group" role="radiogroup" aria-label="" id="group-language">
                <label class="pill-option">
                  <input type="radio" name="language" value="en" checked required />
                  <span class="pill" data-language="en">English</span>
                </label>
                <label class="pill-option">
                  <input type="radio" name="language" value="es" />
                  <span class="pill" data-language="es">Spanish</span>
                </label>
                <label class="pill-option">
                  <input type="radio" name="language" value="fr" />
                  <span class="pill" data-language="fr">French</span>
                </label>
                <label class="pill-option">
                  <input type="radio" name="language" value="de" />
                  <span class="pill" data-language="de">German</span>
                </label>
              </div>
            </label>

            <label>
              <span id="label-voice">Voice</span>
              <div class="pill-group" role="radiogroup" aria-label="" id="group-voice">
                <label class="pill-option">
                  <input type="radio" name="voiceGender" value="female" checked />
                  <span class="pill" data-voice-label="female">Alloy</span>
                </label>
                <label class="pill-option">
                  <input type="radio" name="voiceGender" value="male" required />
                  <span class="pill" data-voice-label="male">Ash</span>
                </label>
              </div>
              <div class="voice-preview">
                <span class="option-hint" id="voice-help">Choose the voice you prefer for guidance.</span>
                <button type="button" id="voice-preview-button">
                  <span id="voice-preview-text">Preview</span>
                  <span id="voice-preview-icon" aria-hidden="true">‚ñ∂</span>
                </button>
              </div>
              <audio id="voice-preview-audio" hidden></audio>
              <span id="voice-preview-status" class="option-hint" hidden></span>
            </label>

            <label>
              <span style="display: inline-flex; align-items: center; gap: 0.35rem;">
                <span id="label-audio-delivery">Audio delivery</span>
                <span
                  class="info-icon"
                  id="audio-delivery-info"
                  aria-label=""
                  data-tooltip=""
                  tabindex="0"
                >
                  i
                </span>
              </span>
              <div style="display: flex; align-items: center; gap: 0.5rem; flex-wrap: wrap;">
                <div
                  class="pill-group"
                  role="radiogroup"
                  aria-label=""
                  id="group-audio-delivery"
                >
                  <label class="pill-option">
                    <input type="radio" name="audioDelivery" value="generate" checked />
                    <span class="pill" data-i18n="form.audio_delivery.generate">Generate</span>
                  </label>
                  <label class="pill-option">
                    <input type="radio" name="audioDelivery" value="stream" />
                    <span class="pill" data-i18n="form.audio_delivery.stream">Stream</span>
                  </label>
                </div>
              </div>
            </label>
          </div>
        </details>

        <div style="display: flex; gap: 0.75rem; flex-wrap: wrap;">
          <button type="submit" id="submit-button" class="button-primary button-large">
            Prepare PQ Reps
          </button>
          <button type="button" id="reset-button" class="button-secondary button-large">
            Reset to defaults
          </button>
        </div>
      </form>

      <section id="status-panel" class="status-panel" hidden>
        <div class="status-row">
          <span id="spinner" class="spinner" aria-hidden="true"></span>
          <p class="status" id="status" aria-live="polite"></p>
        </div>
      </section>
      <div id="error" class="error" hidden></div>

      <section id="result" class="result" hidden>
        <h2 id="result-title">Your session is ready</h2>
        <audio id="audio-player" controls style="width: 100%;" hidden></audio>
        <div class="download-links">
          <a
            id="download-link"
            class="download-link is-disabled"
            download="pq-reps.wav"
            aria-disabled="true"
          >
            Download the audio
          </a>
          <span class="download-separator" aria-hidden="true"> | </span>
          <a
            id="script-download-link"
            class="download-link is-disabled"
            download="pq-reps.txt"
            aria-disabled="true"
          >
            Download the text
          </a>
        </div>
        <p id="script-output" style="margin-top: 1rem; white-space: pre-line;" hidden></p>
        <div id="debug-section" hidden>
          <h3 id="debug-title">TTS prompt (debug)</h3>
          <pre id="debug-output" class="debug-prompt"></pre>
        </div>
      </section>

      <footer class="footer">
        <p id="footer-text" class="footer-text">
          Inspired by publicly available teachings on Positive Intelligence¬Æ and PQ Reps¬Æ by
          Shirzad Chamine. Not affiliated with or endorsed by Positive Intelligence LLC. For
          educational purposes only.
        </p>
        <div class="footer-locale">
          <span class="footer-locale-icon" aria-hidden="true">üåê</span>
          <span class="footer-locale-label" data-i18n="form.language_label">Language:</span>
          <select id="footer-locale-select" aria-label="">
            <option value="en" data-language="en">English</option>
            <option value="es" data-language="es">Spanish</option>
            <option value="fr" data-language="fr">French</option>
            <option value="de" data-language="de">German</option>
          </select>
        </div>
      </footer>
    </main>

    <script>
      const apiKey = __API_KEY__;
      const authHeaders = apiKey ? { Authorization: `Bearer ${apiKey}` } : {};
      const form = document.getElementById("generator-form");
      const scenarioIdInput = document.getElementById("scenario-id");
      const sectionTablist = document.getElementById("section-tablist");
      const quickAccessToggle = document.getElementById("quick-access-toggle");
      const customizeToggle = document.getElementById("customize-toggle");
      const quickAccessSection = document.getElementById("panel-quick");
      const customizeSection = document.getElementById("panel-customize");
      const sectionTabs = [quickAccessToggle, customizeToggle].filter(Boolean);
      const scenarioCards = form.querySelectorAll(".scenario-card");
      const practiceTypeInputs = form.querySelectorAll("input[name='practiceType']");
      const durationInputs = form.querySelectorAll("input[name='durationMinutes']");
      const getSelectedValue = (name) =>
        form.querySelector(`input[name='${name}']:checked`)?.value;
      const status = document.getElementById("status");
      const statusPanel = document.getElementById("status-panel");
      const spinner = document.getElementById("spinner");
      const error = document.getElementById("error");
      const result = document.getElementById("result");
      const audioPlayer = document.getElementById("audio-player");
      const downloadLink = document.getElementById("download-link");
      const scriptDownloadLink = document.getElementById("script-download-link");
      const scriptOutput = document.getElementById("script-output");
      const submitButton = document.getElementById("submit-button");
      const debugInput = form.querySelector("input[name='debugTtsPrompt']");
      const appTitle = document.getElementById("app-title");
      const appVersion = document.getElementById("app-version");
      const appDescription = document.getElementById("app-description");
      const appAiNotice = document.getElementById("app-ai-notice");
      const labelPracticeType = document.getElementById("label-practice-type");
      const labelFocus = document.getElementById("label-focus");
      const labelDuration = document.getElementById("label-duration");
      const labelLanguage = document.getElementById("label-language");
      const labelCustomScenario = document.getElementById("label-custom-scenario");
      const customScenarioHelp = document.getElementById("custom-scenario-help");
      const labelVoice = document.getElementById("label-voice");
      const voiceHelp = document.getElementById("voice-help");
      const voicePreviewText = document.getElementById("voice-preview-text");
      const labelAudioDelivery = document.getElementById("label-audio-delivery");
      const audioDeliveryInfo = document.getElementById("audio-delivery-info");
      const labelTtsNewline = document.getElementById("label-tts-newline");
      const labelDebugTts = document.getElementById("label-debug-tts");
      const debugTtsHelp = document.getElementById("debug-tts-help");
      const resultTitle = document.getElementById("result-title");
      const debugTitle = document.getElementById("debug-title");
      const footerText = document.getElementById("footer-text");
      const footerLocaleSelect = document.getElementById("footer-locale-select");
      const groupPracticeType = document.getElementById("group-practice-type");
      const groupFocus = document.getElementById("group-focus");
      const groupDuration = document.getElementById("group-duration");
      const groupLanguage = document.getElementById("group-language");
      const groupVoice = document.getElementById("group-voice");
      const groupAudioDelivery = document.getElementById("group-audio-delivery");
      const resetButton = document.getElementById("reset-button");
      const debugSection = document.getElementById("debug-section");
      const debugOutput = document.getElementById("debug-output");
      const devControls = document.getElementById("dev-controls");
      let currentUrl = null;
      let downloadUrl = null;
      let scriptDownloadUrl = null;
      const storageKey = "pq-reps-form";
      const femaleVoiceByLanguage = { es: "nova", fr: "nova" };
      const maleVoiceByLanguage = { es: "onyx", fr: "onyx" };
      const previewButton = document.getElementById("voice-preview-button");
      const previewAudio = document.getElementById("voice-preview-audio");
      const previewStatus = document.getElementById("voice-preview-status");
      const previewIcon = document.getElementById("voice-preview-icon");
      let previewPlaying = false;
      const isDevMode = new URLSearchParams(window.location.search).get("dev") === "1";
      const FALLBACK_LOCALE = "en";
      let versionState = "loading";
      let versionValue = "unknown";

      const TRANSLATIONS = {
        en: {
          "ui.title": "PQ Reps Audio Generator",
          "ui.version.loading": "Version: loading...",
          "ui.version.unavailable": "Version: unavailable",
          "ui.version.label": "Version: {version}",
          "ui.description": "Choose the type of PQ Reps you'd like to practice.",
          "ui.ai_notice": "Audio is AI-generated.",
          "form.scenario_controls": "Scenario controls",
          "form.quick_access": "Quick access",
          "form.customize": "Customize",
          "form.options": "Options",
          "ui.footer":
            "Inspired by publicly available teachings on Positive Intelligence¬Æ and PQ Reps¬Æ by Shirzad Chamine. Not affiliated with or endorsed by Positive Intelligence LLC. For educational purposes only.",
          "form.practice_type": "Practice type",
          "form.practice_type.still_eyes_closed": "Still (Eyes closed)",
          "form.practice_type.still_eyes_open": "Still (Eyes open)",
          "form.practice_type.moving": "Moving",
          "form.practice_type.labeling": "Labeling",
          "scenario.calm_me_now": "Calm me now",
          "scenario.get_present_for_meeting": "Get present for a meeting",
          "scenario.start_the_thing_im_avoiding": "Start the thing I‚Äôm avoiding",
          "scenario.prepare_for_a_tough_conversation": "Prepare for a tough conversation",
          "scenario.reset_after_feedback": "Reset after feedback",
          "scenario.wind_down_for_sleep": "Wind down for sleep",
          "scenario.daily_deep_reset": "Daily deep reset",
          "form.focus": "Focus",
          "form.focus.touch": "Touch",
          "form.focus.hearing": "Hearing",
          "form.focus.sight": "Sight",
          "form.focus.breath": "Breath",
          "form.duration": "Duration",
          "form.duration.minutes": "{count} minute{suffix}",
          "form.language": "Language",
          "form.language_label": "Language:",
          "form.language.en": "English",
          "form.language.es": "Spanish",
          "form.language.fr": "French",
          "form.language.de": "German",
          "form.voice": "Voice",
          "form.voice.help": "Choose the voice you prefer for guidance.",
          "form.voice.preview": "Preview",
          "form.custom_scenario_line": "Custom scenario line (optional)",
          "form.custom_scenario_line.help":
            "Add a short, neutral context line (max 120 characters). Avoid URLs or sensitive topics.",
          "form.audio_delivery": "Audio delivery",
          "form.audio_delivery.help":
            "Streaming starts playback sooner but can be less reliable on spotty connections and may limit seeking or offline replay.",
          "form.audio_delivery.generate": "Generate",
          "form.audio_delivery.stream": "Stream",
          "form.tts_newline_pause": "TTS newline pause (seconds)",
          "form.debug_tts_prompt": "Debug TTS prompt",
          "form.debug_tts_prompt.help":
            "Include the raw TTS payload for OpenAI playground testing.",
          "form.submit": "Prepare PQ Reps",
          "form.reset": "Reset to defaults",
          "status.preparing": "Preparing PQ Reps audio. This can take a few seconds.",
          "result.title": "Your session is ready",
          "result.download_audio": "Download the audio",
          "result.download_text": "Download the text",
          "result.debug_title": "TTS prompt (debug)",
          "errors.unknown": "Something went wrong.",
          "errors.generator_failed": "The generator failed to respond.",
          "errors.generator_failed_status": "The generator failed to respond. ({status})",
          "errors.streaming_unavailable": "Streaming updates are not available.",
          "errors.stream_ended": "The stream ended before returning a response.",
          "errors.streaming_failed": "Streaming failed.",
          "errors.audio_stream_failed": "Audio stream failed.",
          "errors.append_audio_chunk_failed": "Failed to append audio chunk.",
          "errors.audio_stream_no_data": "Audio stream ended before data arrived.",
          "errors.preview_failed": "Preview failed.",
          "errors.preview_failed_status": "Preview failed ({status}).",
        },
        es: {
          "ui.title": "Generador de audio de PQ Reps",
          "ui.version.loading": "Versi√≥n: cargando...",
          "ui.version.unavailable": "Versi√≥n: no disponible",
          "ui.version.label": "Versi√≥n: {version}",
          "ui.description": "Elige el tipo de PQ Reps que quieres practicar.",
          "ui.ai_notice": "El audio est√° generado por IA.",
          "form.scenario_controls": "Controles de escenarios",
          "form.quick_access": "Acceso r√°pido",
          "form.customize": "Personalizar",
          "form.options": "Opciones",
          "ui.footer":
            "Inspirado en ense√±anzas p√∫blicas sobre Positive Intelligence¬Æ y PQ Reps¬Æ de Shirzad Chamine. No afiliado ni avalado por Positive Intelligence LLC. Solo con fines educativos.",
          "form.practice_type": "Tipo de pr√°ctica",
          "form.practice_type.still_eyes_closed": "Quieto (ojos cerrados)",
          "form.practice_type.still_eyes_open": "Quieto (ojos abiertos)",
          "form.practice_type.moving": "En movimiento",
          "form.practice_type.labeling": "Etiquetado",
          "scenario.calm_me_now": "C√°lmame ahora",
          "scenario.get_present_for_meeting": "Ponte presente para una reuni√≥n",
          "scenario.start_the_thing_im_avoiding": "Empieza lo que estoy evitando",
          "scenario.prepare_for_a_tough_conversation": "Prep√°rate para una conversaci√≥n dif√≠cil",
          "scenario.reset_after_feedback": "Reaj√∫state despu√©s de comentarios",
          "scenario.wind_down_for_sleep": "Rel√°jate para dormir",
          "scenario.daily_deep_reset": "Reinicio profundo diario",
          "form.focus": "Enfoque",
          "form.focus.touch": "Tacto",
          "form.focus.hearing": "O√≠do",
          "form.focus.sight": "Vista",
          "form.focus.breath": "Respiraci√≥n",
          "form.duration": "Duraci√≥n",
          "form.duration.minutes": "{count} minuto{suffix}",
          "form.language": "Idioma",
          "form.language_label": "Idioma:",
          "form.language.en": "Ingl√©s",
          "form.language.es": "Espa√±ol",
          "form.language.fr": "Franc√©s",
          "form.language.de": "Alem√°n",
          "form.voice": "Voz",
          "form.voice.help": "Elige la voz que prefieres para la gu√≠a.",
          "form.voice.preview": "Vista previa",
          "form.custom_scenario_line": "L√≠nea de escenario personalizada (opcional)",
          "form.custom_scenario_line.help":
            "Agrega una l√≠nea breve y neutral (m√°ximo 120 caracteres). Sin URLs ni temas sensibles.",
          "form.audio_delivery": "Entrega de audio",
          "form.audio_delivery.help":
            "La transmisi√≥n inicia la reproducci√≥n antes, pero puede ser menos fiable con conexiones inestables y limitar la b√∫squeda o la reproducci√≥n sin conexi√≥n.",
          "form.audio_delivery.generate": "Generar",
          "form.audio_delivery.stream": "Transmitir",
          "form.tts_newline_pause": "Pausa de salto de l√≠nea de TTS (segundos)",
          "form.debug_tts_prompt": "Depurar prompt de TTS",
          "form.debug_tts_prompt.help":
            "Incluye la carga √∫til de TTS sin procesar para pruebas en OpenAI playground.",
          "form.submit": "Preparar PQ Reps",
          "form.reset": "Restablecer valores",
          "status.preparing":
            "Preparando el audio de PQ Reps. Esto puede tardar unos segundos.",
          "result.title": "Tu sesi√≥n est√° lista",
          "result.download_audio": "Descargar el audio",
          "result.download_text": "Descargar el texto",
          "result.debug_title": "Prompt de TTS (depuraci√≥n)",
          "errors.unknown": "Algo sali√≥ mal.",
          "errors.generator_failed": "El generador no respondi√≥.",
          "errors.generator_failed_status": "El generador no respondi√≥. ({status})",
          "errors.streaming_unavailable":
            "Las actualizaciones en streaming no est√°n disponibles.",
          "errors.stream_ended": "La transmisi√≥n termin√≥ antes de devolver una respuesta.",
          "errors.streaming_failed": "La transmisi√≥n fall√≥.",
          "errors.audio_stream_failed": "Fall√≥ la transmisi√≥n de audio.",
          "errors.append_audio_chunk_failed": "No se pudo a√±adir el fragmento de audio.",
          "errors.audio_stream_no_data":
            "La transmisi√≥n de audio termin√≥ antes de que llegaran datos.",
          "errors.preview_failed": "Fall√≥ la vista previa.",
          "errors.preview_failed_status": "Fall√≥ la vista previa ({status}).",
        },
        fr: {
          "ui.title": "G√©n√©rateur audio PQ Reps",
          "ui.version.loading": "Version¬†: chargement...",
          "ui.version.unavailable": "Version¬†: indisponible",
          "ui.version.label": "Version¬†: {version}",
          "ui.description": "Choisissez le type de PQ Reps que vous souhaitez pratiquer.",
          "ui.ai_notice": "L'audio est g√©n√©r√© par IA.",
          "form.scenario_controls": "Commandes de sc√©nario",
          "form.quick_access": "Acc√®s rapide",
          "form.customize": "Personnaliser",
          "form.options": "Options",
          "ui.footer":
            "Inspir√© d'enseignements publics sur Positive Intelligence¬Æ et PQ Reps¬Æ de Shirzad Chamine. Non affili√© ni approuv√© par Positive Intelligence LLC. √Ä des fins √©ducatives uniquement.",
          "form.practice_type": "Type de pratique",
          "form.practice_type.still_eyes_closed": "Immobile (yeux ferm√©s)",
          "form.practice_type.still_eyes_open": "Immobile (yeux ouverts)",
          "form.practice_type.moving": "En mouvement",
          "form.practice_type.labeling": "√âtiquetage",
          "scenario.calm_me_now": "Calme-moi maintenant",
          "scenario.get_present_for_meeting": "Me rendre pr√©sent pour une r√©union",
          "scenario.start_the_thing_im_avoiding": "Commencer ce que j‚Äô√©vite",
          "scenario.prepare_for_a_tough_conversation": "Se pr√©parer √† une conversation difficile",
          "scenario.reset_after_feedback": "Se recentrer apr√®s un retour",
          "scenario.wind_down_for_sleep": "Se d√©tendre pour dormir",
          "scenario.daily_deep_reset": "R√©initialisation profonde quotidienne",
          "form.focus": "Focus",
          "form.focus.touch": "Toucher",
          "form.focus.hearing": "Ou√Øe",
          "form.focus.sight": "Vue",
          "form.focus.breath": "Respiration",
          "form.duration": "Dur√©e",
          "form.duration.minutes": "{count} minute{suffix}",
          "form.language": "Langue",
          "form.language_label": "Langue¬†:",
          "form.language.en": "Anglais",
          "form.language.es": "Espagnol",
          "form.language.fr": "Fran√ßais",
          "form.language.de": "Allemand",
          "form.voice": "Voix",
          "form.voice.help": "Choisissez la voix que vous pr√©f√©rez pour la guidance.",
          "form.voice.preview": "Aper√ßu",
          "form.custom_scenario_line": "Ligne de sc√©nario personnalis√©e (optionnel)",
          "form.custom_scenario_line.help":
            "Ajoutez une ligne courte et neutre (max 120 caract√®res). Pas d'URL ni de sujets sensibles.",
          "form.audio_delivery": "Diffusion audio",
          "form.audio_delivery.help":
            "La diffusion d√©marre plus t√¥t, mais peut √™tre moins fiable sur des connexions instables et limiter la recherche ou l'√©coute hors ligne.",
          "form.audio_delivery.generate": "G√©n√©rer",
          "form.audio_delivery.stream": "Diffuser",
          "form.tts_newline_pause": "Pause de retour √† la ligne TTS (secondes)",
          "form.debug_tts_prompt": "D√©boguer le prompt TTS",
          "form.debug_tts_prompt.help":
            "Inclure la charge utile TTS brute pour les tests OpenAI playground.",
          "form.submit": "Pr√©parer PQ Reps",
          "form.reset": "R√©initialiser",
          "status.preparing":
            "Pr√©paration de l'audio PQ Reps. Cela peut prendre quelques secondes.",
          "result.title": "Votre session est pr√™te",
          "result.download_audio": "T√©l√©charger l'audio",
          "result.download_text": "T√©l√©charger le texte",
          "result.debug_title": "Prompt TTS (debug)",
          "errors.unknown": "Une erreur est survenue.",
          "errors.generator_failed": "Le g√©n√©rateur n'a pas r√©pondu.",
          "errors.generator_failed_status": "Le g√©n√©rateur n'a pas r√©pondu. ({status})",
          "errors.streaming_unavailable":
            "Les mises √† jour en streaming ne sont pas disponibles.",
          "errors.stream_ended": "Le flux s'est termin√© avant d'envoyer une r√©ponse.",
          "errors.streaming_failed": "Le streaming a √©chou√©.",
          "errors.audio_stream_failed": "Le flux audio a √©chou√©.",
          "errors.append_audio_chunk_failed": "Impossible d'ajouter le fragment audio.",
          "errors.audio_stream_no_data":
            "Le flux audio s'est termin√© avant l'arriv√©e des donn√©es.",
          "errors.preview_failed": "L'aper√ßu a √©chou√©.",
          "errors.preview_failed_status": "L'aper√ßu a √©chou√© ({status}).",
        },
        de: {
          "ui.title": "PQ Reps Audio-Generator",
          "ui.version.loading": "Version: wird geladen...",
          "ui.version.unavailable": "Version: nicht verf√ºgbar",
          "ui.version.label": "Version: {version}",
          "ui.description": "W√§hle die Art der PQ Reps, die du √ºben m√∂chtest.",
          "ui.ai_notice": "Audio wird von KI erzeugt.",
          "form.scenario_controls": "Szenario-Steuerung",
          "form.quick_access": "Schnellzugriff",
          "form.customize": "Anpassen",
          "form.options": "Optionen",
          "ui.footer":
            "Inspiriert von √∂ffentlich verf√ºgbaren Lehren zu Positive Intelligence¬Æ und PQ Reps¬Æ von Shirzad Chamine. Nicht verbunden oder unterst√ºtzt von Positive Intelligence LLC. Nur zu Bildungszwecken.",
          "form.practice_type": "Praxisart",
          "form.practice_type.still_eyes_closed": "Still (Augen geschlossen)",
          "form.practice_type.still_eyes_open": "Still (Augen offen)",
          "form.practice_type.moving": "In Bewegung",
          "form.practice_type.labeling": "Benennen",
          "scenario.calm_me_now": "Beruhige mich jetzt",
          "scenario.get_present_for_meeting": "F√ºr ein Meeting pr√§sent werden",
          "scenario.start_the_thing_im_avoiding": "Starte das, was ich vermeide",
          "scenario.prepare_for_a_tough_conversation": "Bereite dich auf ein schwieriges Gespr√§ch vor",
          "scenario.reset_after_feedback": "Nach Feedback neu ausrichten",
          "scenario.wind_down_for_sleep": "Zur Ruhe kommen f√ºrs Einschlafen",
          "scenario.daily_deep_reset": "T√§glicher tiefer Reset",
          "form.focus": "Fokus",
          "form.focus.touch": "Ber√ºhrung",
          "form.focus.hearing": "H√∂ren",
          "form.focus.sight": "Sehen",
          "form.focus.breath": "Atmung",
          "form.duration": "Dauer",
          "form.duration.minutes": "{count} Minute{suffix}",
          "form.language": "Sprache",
          "form.language_label": "Sprache:",
          "form.language.en": "Englisch",
          "form.language.es": "Spanisch",
          "form.language.fr": "Franz√∂sisch",
          "form.language.de": "Deutsch",
          "form.voice": "Stimme",
          "form.voice.help": "W√§hle die Stimme, die du f√ºr die Anleitung bevorzugst.",
          "form.voice.preview": "Vorschau",
          "form.custom_scenario_line": "Benutzerdefinierte Szenariozeile (optional)",
          "form.custom_scenario_line.help":
            "F√ºge eine kurze, neutrale Zeile hinzu (max 120 Zeichen). Keine URLs oder sensible Themen.",
          "form.audio_delivery": "Audio√ºbertragung",
          "form.audio_delivery.help":
            "Streaming startet die Wiedergabe fr√ºher, kann aber bei instabilen Verbindungen unzuverl√§ssiger sein und das Suchen oder Offline-H√∂ren einschr√§nken.",
          "form.audio_delivery.generate": "Erzeugen",
          "form.audio_delivery.stream": "Streamen",
          "form.tts_newline_pause": "TTS-Zeilenumbruchpause (Sekunden)",
          "form.debug_tts_prompt": "TTS-Prompt debuggen",
          "form.debug_tts_prompt.help":
            "F√ºgt die rohe TTS-Nutzlast f√ºr Tests im OpenAI Playground hinzu.",
          "form.submit": "PQ Reps vorbereiten",
          "form.reset": "Auf Standard zur√ºcksetzen",
          "status.preparing":
            "PQ-Reps-Audio wird vorbereitet. Das kann ein paar Sekunden dauern.",
          "result.title": "Deine Sitzung ist bereit",
          "result.download_audio": "Audio herunterladen",
          "result.download_text": "Text herunterladen",
          "result.debug_title": "TTS-Prompt (Debug)",
          "errors.unknown": "Es ist ein Fehler aufgetreten.",
          "errors.generator_failed": "Der Generator hat nicht geantwortet.",
          "errors.generator_failed_status": "Der Generator hat nicht geantwortet. ({status})",
          "errors.streaming_unavailable": "Streaming-Updates sind nicht verf√ºgbar.",
          "errors.stream_ended": "Der Stream endete, bevor eine Antwort zur√ºckkam.",
          "errors.streaming_failed": "Streaming fehlgeschlagen.",
          "errors.audio_stream_failed": "Audio-Stream fehlgeschlagen.",
          "errors.append_audio_chunk_failed": "Audio-Chunk konnte nicht hinzugef√ºgt werden.",
          "errors.audio_stream_no_data":
            "Der Audio-Stream endete, bevor Daten ankamen.",
          "errors.preview_failed": "Vorschau fehlgeschlagen.",
          "errors.preview_failed_status": "Vorschau fehlgeschlagen ({status}).",
        },
      };

      if (devControls) {
        devControls.hidden = !isDevMode;
      }

      const setDownloadLinkState = (link, { enabled, href } = {}) => {
        const isEnabled = Boolean(enabled);
        link.classList.toggle("is-disabled", !isEnabled);
        link.setAttribute("aria-disabled", String(!isEnabled));
        link.tabIndex = isEnabled ? 0 : -1;
        if (isEnabled && href) {
          link.href = href;
        } else {
          link.removeAttribute("href");
        }
      };

      const clearScenarioSelection = () => {
        scenarioCards.forEach((card) => card.classList.remove("is-selected"));
        if (scenarioIdInput) {
          scenarioIdInput.value = "";
        }
      };

      const setActiveSection = (section, { preserveScenario = false } = {}) => {
        const showQuick = section === "quick";
        if (quickAccessSection) {
          quickAccessSection.hidden = !showQuick;
        }
        if (customizeSection) {
          customizeSection.hidden = showQuick;
        }
        if (quickAccessToggle) {
          quickAccessToggle.classList.toggle("is-active", showQuick);
          quickAccessToggle.setAttribute("aria-selected", String(showQuick));
          quickAccessToggle.tabIndex = showQuick ? 0 : -1;
        }
        if (customizeToggle) {
          customizeToggle.classList.toggle("is-active", !showQuick);
          customizeToggle.setAttribute("aria-selected", String(!showQuick));
          customizeToggle.tabIndex = showQuick ? -1 : 0;
        }
        if (!showQuick && !preserveScenario) {
          clearScenarioSelection();
        }
      };

      const focusSectionTab = (index) => {
        const tab = sectionTabs[index];
        if (tab instanceof HTMLElement) {
          tab.focus();
        }
      };

      const handleSectionTabKeyDown = (event) => {
        if (event.key !== "ArrowLeft" && event.key !== "ArrowRight") {
          return;
        }
        event.preventDefault();
        const direction = event.key === "ArrowRight" ? 1 : -1;
        const currentIndex = sectionTabs.indexOf(event.currentTarget);
        if (currentIndex === -1) {
          return;
        }
        const nextIndex = (currentIndex + direction + sectionTabs.length) % sectionTabs.length;
        const nextTab = sectionTabs[nextIndex];
        if (nextTab === quickAccessToggle) {
          setActiveSection("quick", { preserveScenario: true });
        } else {
          setActiveSection("customize");
        }
        requestAnimationFrame(() => focusSectionTab(nextIndex));
      };

      const syncScenarioSelection = () => {
        if (!scenarioIdInput) {
          return;
        }
        const scenarioId = scenarioIdInput.value;
        scenarioCards.forEach((card) => {
          card.classList.toggle("is-selected", card.dataset.scenarioId === scenarioId);
        });
        if (scenarioId) {
          setActiveSection("quick", { preserveScenario: true });
        }
      };

      const derivePracticeConfig = (practiceType, durationMinutes) => {
        if (practiceType === "still_eyes_closed") {
          return {
            practiceMode: "tactile",
            bodyState: "still_seated_closed_eyes",
            eyeState: "closed",
            labelingMode: "none",
          };
        }
        if (practiceType === "still_eyes_open") {
          return {
            practiceMode: "sitting",
            bodyState: "still_seated",
            eyeState: "open_diffused",
            labelingMode: "none",
          };
        }
        if (practiceType === "moving") {
          return {
            practiceMode: "moving",
            bodyState: "moving",
            eyeState: "open_focused",
            labelingMode: "none",
          };
        }
        const labelingMode = durationMinutes < 5 ? "breath_anchor" : "scan_and_label";
        return {
          practiceMode: durationMinutes < 5 ? "label_with_anchor" : "label_while_scanning",
          bodyState: "still_seated_closed_eyes",
          eyeState: "closed",
          labelingMode,
        };
      };

      const deriveDurationConfig = (durationMinutes) => {
        if (durationMinutes === 1 || durationMinutes === 2) {
          return {
            silenceProfile: "none",
            normalizationFrequency: "once",
            closingStyle: "minimal",
          };
        }
        if (durationMinutes === 5) {
          return {
            silenceProfile: "short_pauses",
            normalizationFrequency: "periodic",
            closingStyle: "pq_framed",
          };
        }
        return {
          silenceProfile: "extended_silence",
          normalizationFrequency: "repeated",
          closingStyle: "pq_framed_with_progression",
        };
      };

      const deriveSenseRotation = (practiceType, durationMinutes) => {
        if (durationMinutes >= 5 && practiceType !== "labeling") {
          return "guided_rotation";
        }
        return "none";
      };

      const resolveLocale = (value) => {
        if (!value) {
          return FALLBACK_LOCALE;
        }
        const normalized = value.toLowerCase();
        const base = normalized.split("-")[0];
        return TRANSLATIONS[base] ? base : FALLBACK_LOCALE;
      };

      const getLocaleFromPath = () => {
        const match = window.location.pathname.match(/^\/(en|es|fr|de)(?:\/|$)/);
        return match ? match[1] : null;
      };

      const buildLocalePath = (locale) => {
        const pathname = window.location.pathname;
        const updated = pathname.replace(/^\/(en|es|fr|de)(?=\/|$)/, `/${locale}`);
        if (updated === pathname) {
          return `/${locale}${pathname === "/" ? "" : pathname}`;
        }
        return updated;
      };

      const getCurrentLocale = () => resolveLocale(getLocaleFromPath() || FALLBACK_LOCALE);

      const translate = (key, params = {}, locale = getCurrentLocale()) => {
        const template =
          TRANSLATIONS[locale]?.[key] ?? TRANSLATIONS[FALLBACK_LOCALE]?.[key] ?? key;
        return Object.entries(params).reduce(
          (result, [paramKey, value]) =>
            result.replaceAll(`{${paramKey}}`, String(value)),
          template,
        );
      };

      const formatDurationLabel = (minutes, locale = getCurrentLocale()) => {
        let suffix = "s";
        if (locale === "de") {
          suffix = minutes === 1 ? "" : "n";
        } else if (minutes === 1) {
          suffix = "";
        }
        return translate("form.duration.minutes", { count: minutes, suffix }, locale);
      };

      const updateVersionText = () => {
        if (!appVersion) {
          return;
        }
        const locale = getCurrentLocale();
        if (versionState === "loaded") {
          appVersion.textContent = translate(
            "ui.version.label",
            { version: versionValue },
            locale,
          );
          return;
        }
        if (versionState === "error") {
          appVersion.textContent = translate("ui.version.unavailable", {}, locale);
          return;
        }
        appVersion.textContent = translate("ui.version.loading", {}, locale);
      };

      const applyTranslations = () => {
        const locale = getCurrentLocale();
        document.documentElement.lang = locale;
        if (sectionTablist) {
          sectionTablist.setAttribute(
            "aria-label",
            translate("form.scenario_controls", {}, locale),
          );
        }
        if (appTitle) {
          appTitle.textContent = translate("ui.title", {}, locale);
        }
        if (appDescription) {
          appDescription.textContent = translate("ui.description", {}, locale);
        }
        if (appAiNotice) {
          appAiNotice.textContent = translate("ui.ai_notice", {}, locale);
        }
        if (labelPracticeType) {
          labelPracticeType.textContent = translate("form.practice_type", {}, locale);
        }
        if (labelFocus) {
          labelFocus.textContent = translate("form.focus", {}, locale);
        }
        if (labelDuration) {
          labelDuration.textContent = translate("form.duration", {}, locale);
        }
        if (labelLanguage) {
          labelLanguage.textContent = translate("form.language", {}, locale);
        }
        if (labelCustomScenario) {
          labelCustomScenario.textContent = translate("form.custom_scenario_line", {}, locale);
        }
        if (customScenarioHelp) {
          customScenarioHelp.textContent = translate(
            "form.custom_scenario_line.help",
            {},
            locale,
          );
        }
        if (labelVoice) {
          labelVoice.textContent = translate("form.voice", {}, locale);
        }
        if (voiceHelp) {
          voiceHelp.textContent = translate("form.voice.help", {}, locale);
        }
        if (voicePreviewText) {
          voicePreviewText.textContent = translate("form.voice.preview", {}, locale);
        }
        if (labelAudioDelivery) {
          labelAudioDelivery.textContent = translate("form.audio_delivery", {}, locale);
        }
        if (audioDeliveryInfo) {
          const helpText = translate("form.audio_delivery.help", {}, locale);
          audioDeliveryInfo.setAttribute("aria-label", helpText);
          audioDeliveryInfo.setAttribute("data-tooltip", helpText);
        }
        if (labelTtsNewline) {
          labelTtsNewline.textContent = translate("form.tts_newline_pause", {}, locale);
        }
        if (labelDebugTts) {
          labelDebugTts.textContent = translate("form.debug_tts_prompt", {}, locale);
        }
        if (debugTtsHelp) {
          debugTtsHelp.textContent = translate("form.debug_tts_prompt.help", {}, locale);
        }
        if (submitButton) {
          submitButton.textContent = translate("form.submit", {}, locale);
        }
        if (resetButton) {
          resetButton.textContent = translate("form.reset", {}, locale);
        }
        if (resultTitle) {
          resultTitle.textContent = translate("result.title", {}, locale);
        }
        if (downloadLink) {
          downloadLink.textContent = translate("result.download_audio", {}, locale);
        }
        if (scriptDownloadLink) {
          scriptDownloadLink.textContent = translate("result.download_text", {}, locale);
        }
        if (debugTitle) {
          debugTitle.textContent = translate("result.debug_title", {}, locale);
        }
        if (footerText) {
          footerText.textContent = translate("ui.footer", {}, locale);
        }
        if (footerLocaleSelect) {
          footerLocaleSelect.value = locale;
          footerLocaleSelect.setAttribute("aria-label", translate("form.language", {}, locale));
        }
        if (groupPracticeType) {
          groupPracticeType.setAttribute("aria-label", translate("form.practice_type", {}, locale));
        }
        if (groupFocus) {
          groupFocus.setAttribute("aria-label", translate("form.focus", {}, locale));
        }
        if (groupDuration) {
          groupDuration.setAttribute("aria-label", translate("form.duration", {}, locale));
        }
        if (groupLanguage) {
          groupLanguage.setAttribute("aria-label", translate("form.language", {}, locale));
        }
        if (groupVoice) {
          groupVoice.setAttribute("aria-label", translate("form.voice", {}, locale));
        }
        if (groupAudioDelivery) {
          groupAudioDelivery.setAttribute("aria-label", translate("form.audio_delivery", {}, locale));
        }
        document.querySelectorAll("[data-i18n]").forEach((element) => {
          const key = element.getAttribute("data-i18n");
          if (!key) {
            return;
          }
          element.textContent = translate(key, {}, locale);
        });
        document.querySelectorAll("[data-language]").forEach((element) => {
          const langKey = element.getAttribute("data-language");
          if (!langKey) {
            return;
          }
          element.textContent = translate(`form.language.${langKey}`, {}, locale);
        });
        document.querySelectorAll("[data-duration]").forEach((element) => {
          const value = Number(element.getAttribute("data-duration"));
          if (!Number.isFinite(value)) {
            return;
          }
          element.textContent = formatDurationLabel(value, locale);
        });
        updateVersionText();
      };

      const formatTimestamp = (date) => {
        const year = date.getFullYear();
        const month = String(date.getMonth() + 1).padStart(2, "0");
        const day = String(date.getDate()).padStart(2, "0");
        const hour = String(date.getHours()).padStart(2, "0");
        const minute = String(date.getMinutes()).padStart(2, "0");
        return `${year}${month}${day}-${hour}${minute}`;
      };

      const buildDownloadFilename = ({
        voice,
        durationMinutes,
        focus,
        now = new Date(),
        extension = "wav",
      }) => `pq-reps_${voice}_${durationMinutes}_${focus}_${formatTimestamp(now)}.${extension}`;

      const resolveAudioExtension = (contentType) =>
        contentType && contentType.includes("mpeg") ? "mp3" : "wav";
      const resolveStreamingMimeType = (contentType) =>
        contentType && contentType.includes("audio/wav")
          ? 'audio/wav; codecs="1"'
          : contentType;
      const capitalize = (value) => value.charAt(0).toUpperCase() + value.slice(1);
      const resolveVoiceLabel = (gender, language) =>
        capitalize(
          gender === "male"
            ? maleVoiceByLanguage[language] || "ash"
            : femaleVoiceByLanguage[language] || "alloy",
        );
      const parseWavHeader = (header) => {
        const readString = (offset, length) =>
          String.fromCharCode(...header.slice(offset, offset + length));
        if (readString(0, 4) !== "RIFF" || readString(8, 4) !== "WAVE") {
          throw new Error("Invalid WAV header.");
        }
        let offset = 12;
        let fmt = null;
        let dataOffset = null;
        while (offset + 8 <= header.length) {
          const chunkId = readString(offset, 4);
          const chunkSize =
            header[offset + 4] |
            (header[offset + 5] << 8) |
            (header[offset + 6] << 16) |
            (header[offset + 7] << 24);
          const chunkStart = offset + 8;
          if (chunkId === "fmt ") {
            const audioFormat = header[chunkStart] | (header[chunkStart + 1] << 8);
            const channels = header[chunkStart + 2] | (header[chunkStart + 3] << 8);
            const sampleRate =
              header[chunkStart + 4] |
              (header[chunkStart + 5] << 8) |
              (header[chunkStart + 6] << 16) |
              (header[chunkStart + 7] << 24);
            const bitsPerSample =
              header[chunkStart + 14] | (header[chunkStart + 15] << 8);
            fmt = { audioFormat, channels, sampleRate, bitsPerSample };
          } else if (chunkId === "data") {
            dataOffset = chunkStart;
            break;
          }
          offset = chunkStart + chunkSize + (chunkSize % 2);
        }
        if (!fmt || dataOffset === null) {
          throw new Error("Unsupported WAV header.");
        }
        if (fmt.audioFormat !== 1) {
          throw new Error("Only PCM WAV is supported for streaming.");
        }
        return { ...fmt, dataOffset };
      };
      const streamWavViaWebAudio = async ({ reader, onStreamStart, onChunk }) => {
        const bufferSize = 4096;
        let audioContext = null;
        let activeProcessor = null;
        let streamDestination = null;
        const sampleQueue = [];
        let sampleOffset = 0;
        let wavInfo = null;
        let pendingPcmBytes = new Uint8Array(0);
        let headerBytes = new Uint8Array(0);
        let playbackStarted = false;
        let streamingEnabled = true;

        const readSample = () => {
          while (sampleQueue.length > 0 && sampleOffset >= sampleQueue[0].length) {
            sampleQueue.shift();
            sampleOffset = 0;
          }
          if (sampleQueue.length === 0) {
            return null;
          }
          const value = sampleQueue[0][sampleOffset];
          sampleOffset += 1;
          return value;
        };

        const handleAudioProcess = (event) => {
          if (!wavInfo) {
            return;
          }
          const channelCount = wavInfo.channels;
          const outputs = Array.from({ length: channelCount }, (_, idx) =>
            event.outputBuffer.getChannelData(idx),
          );
          for (let i = 0; i < outputs[0].length; i += 1) {
            for (let channel = 0; channel < channelCount; channel += 1) {
              const sample = readSample();
              outputs[channel][i] = sample === null ? 0 : sample;
            }
          }
        };

        const enqueuePcm = (pcmBytes) => {
          if (!wavInfo || wavInfo.bitsPerSample !== 16) {
            return;
          }
          const frameSize = wavInfo.channels * (wavInfo.bitsPerSample / 8);
          const combined = new Uint8Array(pendingPcmBytes.length + pcmBytes.length);
          combined.set(pendingPcmBytes);
          combined.set(pcmBytes, pendingPcmBytes.length);
          const remainder = combined.length % frameSize;
          const alignedLength = combined.length - remainder;
          pendingPcmBytes = remainder > 0 ? combined.slice(alignedLength) : new Uint8Array(0);
          if (alignedLength === 0) {
            return;
          }
          const alignedBytes = combined.slice(0, alignedLength);
          const samples = new Float32Array(alignedBytes.length / 2);
          for (let i = 0; i < alignedBytes.length; i += 2) {
            const int16 = alignedBytes[i] | (alignedBytes[i + 1] << 8);
            const signed = int16 >= 0x8000 ? int16 - 0x10000 : int16;
            samples[i / 2] = signed / 32768;
          }
          sampleQueue.push(samples);
        };

        const waitForDrain = async () =>
          new Promise((resolve) => {
            const checkQueue = () => {
              if (!streamingEnabled || sampleQueue.length === 0) {
                resolve();
                return;
              }
              setTimeout(checkQueue, 100);
            };
            checkQueue();
          });

        while (true) {
          const { value, done } = await reader.read();
          if (done) {
            break;
          }
          if (!value) {
            continue;
          }
          onChunk?.(value);

          if (!wavInfo && streamingEnabled) {
            const combined = new Uint8Array(headerBytes.length + value.length);
            combined.set(headerBytes);
            combined.set(value, headerBytes.length);
            headerBytes = combined;
            if (headerBytes.length >= 44) {
              try {
                wavInfo = parseWavHeader(headerBytes);
                if (wavInfo.bitsPerSample !== 16) {
                  throw new Error("Only 16-bit PCM WAV streaming is supported.");
                }
                audioContext = new AudioContext({ sampleRate: wavInfo.sampleRate });
                await audioContext.resume();
                streamDestination = audioContext.createMediaStreamDestination();
                activeProcessor = audioContext.createScriptProcessor(
                  bufferSize,
                  0,
                  wavInfo.channels,
                );
                activeProcessor.onaudioprocess = handleAudioProcess;
                activeProcessor.connect(streamDestination);
                if (!playbackStarted) {
                  playbackStarted = true;
                  onStreamStart?.(streamDestination.stream);
                }
                const pcmStart = headerBytes.slice(wavInfo.dataOffset);
                enqueuePcm(pcmStart);
                headerBytes = new Uint8Array(0);
              } catch (error) {
                streamingEnabled = false;
              }
            }
            continue;
          }

          if (streamingEnabled && !playbackStarted && streamDestination) {
            playbackStarted = true;
            onStreamStart?.(streamDestination.stream);
          }
          if (streamingEnabled) {
            enqueuePcm(value);
          }
        }

        if (streamingEnabled) {
          await waitForDrain();
        }
        if (activeProcessor) {
          activeProcessor.disconnect();
        }
        if (audioContext) {
          audioContext.close().catch(() => {});
        }
      };
      const buildScriptDownloadFilename = ({ voice, durationMinutes, focus, now = new Date() }) =>
        buildDownloadFilename({ voice, durationMinutes, focus, now }).replace(/\.[^.]+$/, ".txt");

      const derivePrimarySense = (focus, eyeState) => {
        if (focus === "sight" && eyeState === "closed") {
          return "touch";
        }
        return focus;
      };

      const updateFocusOptions = (eyeState) => {
        const sightOption = form.querySelector("input[name='focus'][value='sight']");
        const touchOption = form.querySelector("input[name='focus'][value='touch']");
        if (!sightOption || !touchOption) {
          return;
        }
        if (eyeState === "closed") {
          sightOption.disabled = true;
          if (sightOption.checked) {
            touchOption.checked = true;
          }
        } else {
          sightOption.disabled = false;
        }
      };

      const updateDerivedFields = () => {
        const practiceType = getSelectedValue("practiceType");
        const durationMinutes = Number(getSelectedValue("durationMinutes"));
        if (!practiceType || Number.isNaN(durationMinutes)) {
          return;
        }
        const { eyeState } = derivePracticeConfig(practiceType, durationMinutes);
        updateFocusOptions(eyeState);
      };

      const selectScenarioCard = (card) => {
        const scenarioId = card.dataset.scenarioId;
        const practiceType = card.dataset.practiceType;
        const focus = card.dataset.focus;
        const duration = card.dataset.durationMinutes;
        if (!scenarioId || !practiceType || !focus || !duration) {
          return;
        }
        clearScenarioSelection();
        card.classList.add("is-selected");
        if (scenarioIdInput) {
          scenarioIdInput.value = scenarioId;
        }
        setFormValues({
          practiceType,
          focus,
          durationMinutes: duration,
        });
        updateDerivedFields();
        persistFormValues();
      };

      const updateVoiceLabels = () => {
        const language = getSelectedValue("language") || "en";
        form.querySelectorAll("[data-voice-label]").forEach((label) => {
          const gender = label.getAttribute("data-voice-label");
          if (!gender) {
            return;
          }
          label.textContent = resolveVoiceLabel(gender, language);
        });
      };

      const getFormValues = () => {
        const formData = new FormData(form);
        return Object.fromEntries(formData.entries());
      };

      const setFormValues = (values) => {
        Object.entries(values).forEach(([name, value]) => {
          const field = form.elements.namedItem(name);
          if (field && "value" in field && value != null) {
            field.value = value;
          }
        });
      };

      const defaultValues = getFormValues();

      const storedValuesRaw = localStorage.getItem(storageKey);
      let storedValues = null;
      if (storedValuesRaw) {
        try {
          storedValues = JSON.parse(storedValuesRaw);
        } catch (err) {
          localStorage.removeItem(storageKey);
        }
      }

      const persistFormValues = () => {
        localStorage.setItem(storageKey, JSON.stringify(getFormValues()));
      };

      const pathLocale = getLocaleFromPath();
      const mergedValues = {
        ...defaultValues,
        ...(storedValues && typeof storedValues === "object" ? storedValues : {}),
        ...(pathLocale && !(storedValues && storedValues.language)
          ? { language: pathLocale }
          : {}),
      };
      setFormValues(mergedValues);
      if (pathLocale) {
        persistFormValues();
      }

      updateDerivedFields();
      updateVoiceLabels();
      applyTranslations();
      syncScenarioSelection();
      if (quickAccessToggle) {
        quickAccessToggle.addEventListener("click", () => {
          setActiveSection("quick", { preserveScenario: true });
        });
        quickAccessToggle.addEventListener("keydown", handleSectionTabKeyDown);
      }
      if (customizeToggle) {
        customizeToggle.addEventListener("click", () => {
          setActiveSection("customize");
        });
        customizeToggle.addEventListener("keydown", handleSectionTabKeyDown);
      }
      scenarioCards.forEach((card) => {
        card.addEventListener("click", () => {
          setActiveSection("quick", { preserveScenario: true });
          selectScenarioCard(card);
        });
      });
      durationInputs.forEach((input) => {
        input.addEventListener("change", updateDerivedFields);
      });
      practiceTypeInputs.forEach((input) => {
        input.addEventListener("change", updateDerivedFields);
      });
      form.querySelectorAll("input[name='language']").forEach((input) => {
        input.addEventListener("change", () => {
          updateVoiceLabels();
          applyTranslations();
          persistFormValues();
        });
      });
      if (footerLocaleSelect) {
        footerLocaleSelect.addEventListener("change", (event) => {
          const target = event.target;
          if (!(target instanceof HTMLSelectElement)) {
            return;
          }
          const nextLocale = resolveLocale(target.value);
          if (nextLocale === getCurrentLocale()) {
            return;
          }
          const nextPath = buildLocalePath(nextLocale);
          window.history.replaceState(
            {},
            "",
            `${nextPath}${window.location.search}${window.location.hash}`,
          );
          applyTranslations();
        });
      }

      const setPreviewIcon = (state) => {
        if (!previewIcon) {
          return;
        }
        if (state === "loading") {
          previewIcon.textContent = "‚è≥";
        } else if (state === "playing") {
          previewIcon.textContent = "‚ñ†";
        } else {
          previewIcon.textContent = "‚ñ∂";
        }
      };

      const setPreviewError = (message) => {
        if (!previewStatus) {
          return;
        }
        if (message) {
          previewStatus.hidden = false;
          previewStatus.textContent = message;
        } else {
          previewStatus.hidden = true;
          previewStatus.textContent = "";
        }
      };

      const stopPreview = () => {
        if (!previewAudio) {
          return;
        }
        previewAudio.pause();
        previewAudio.currentTime = 0;
        previewPlaying = false;
        setPreviewIcon("idle");
      };

      const playPreview = async () => {
        if (!previewAudio || !previewStatus || !previewButton) {
          return;
        }
        if (previewPlaying) {
          stopPreview();
          return;
        }
        const language = getSelectedValue("language") || "en";
        const voiceGender = getSelectedValue("voiceGender") || "female";
        const voice =
          voiceGender === "male"
            ? maleVoiceByLanguage[language] || "ash"
            : femaleVoiceByLanguage[language] || "alloy";
        setPreviewError("");
        setPreviewIcon("loading");
        previewButton.disabled = true;
        try {
          const response = await fetch("/api/voice-preview", {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
              Accept: "audio/wav",
              ...authHeaders,
            },
            body: JSON.stringify({
              language,
              voice,
            }),
          });
          if (!response.ok) {
            throw new Error(
              translate("errors.preview_failed_status", { status: response.status }),
            );
          }
          const contentType = response.headers.get("content-type") || "audio/wav";
          const audioBuffer = await response.arrayBuffer();
          const audioBlob = new Blob([audioBuffer], { type: contentType });
          if (previewAudio.src) {
            URL.revokeObjectURL(previewAudio.src);
          }
          previewAudio.src = URL.createObjectURL(audioBlob);
          previewAudio.hidden = false;
          await previewAudio.play();
          previewPlaying = true;
          setPreviewIcon("playing");
          previewAudio.onended = () => {
            previewPlaying = false;
            setPreviewIcon("idle");
          };
          previewAudio.onpause = () => {
            previewPlaying = false;
            setPreviewIcon("idle");
          };
        } catch (error) {
          previewPlaying = false;
          setPreviewIcon("idle");
          setPreviewError(
            error instanceof Error ? error.message : translate("errors.preview_failed"),
          );
        } finally {
          previewButton.disabled = false;
        }
      };

      if (previewButton) {
        previewButton.addEventListener("click", () => {
          playPreview();
        });
      }

      const loadVersion = async () => {
        if (!appVersion) {
          return;
        }
        versionState = "loading";
        updateVersionText();
        try {
          const response = await fetch("/version", {
            headers: {
              ...authHeaders,
            },
          });
          if (!response.ok) {
            throw new Error("version_unavailable");
          }
          const data = await response.json();
          versionValue = data?.version || "unknown";
          versionState = "loaded";
          updateVersionText();
        } catch (err) {
          versionState = "error";
          updateVersionText();
        }
      };

      loadVersion();
      resetButton.addEventListener("click", () => {
        setFormValues(defaultValues);
        clearScenarioSelection();
        setActiveSection("quick", { preserveScenario: true });
        updateDerivedFields();
        updateVoiceLabels();
        applyTranslations();
        localStorage.removeItem(storageKey);
      });

      form.addEventListener("submit", async (event) => {
        event.preventDefault();
        error.hidden = true;
        error.textContent = "";
        status.textContent = "";
        statusPanel.hidden = true;
        spinner.hidden = true;
        result.hidden = true;
        scriptOutput.textContent = "";
        debugOutput.textContent = "";
        debugSection.hidden = true;
        setDownloadLinkState(downloadLink, { enabled: false });
        setDownloadLinkState(scriptDownloadLink, { enabled: false });

        if (currentUrl) {
          URL.revokeObjectURL(currentUrl);
          currentUrl = null;
        }
        if (downloadUrl) {
          URL.revokeObjectURL(downloadUrl);
          downloadUrl = null;
        }
        if (scriptDownloadUrl) {
          URL.revokeObjectURL(scriptDownloadUrl);
          scriptDownloadUrl = null;
        }

        const formData = new FormData(form);
        localStorage.setItem(storageKey, JSON.stringify(Object.fromEntries(formData.entries())));
        const debugEnabled = isDevMode && debugInput?.checked;
        const audioDelivery = getSelectedValue("audioDelivery") || "generate";
        const streamAudioEnabled = audioDelivery === "stream";
        const effectiveOutputMode = streamAudioEnabled ? "audio" : "text-audio";
        const language = formData.get("language");
        const voiceGender = formData.get("voiceGender");
        const voiceStyle =
          voiceGender === "male"
            ? maleVoiceByLanguage[language] || "ash"
            : femaleVoiceByLanguage[language] || "alloy";
        const practiceType = formData.get("practiceType");
        const durationMinutes = Number(formData.get("durationMinutes"));
        const focus = formData.get("focus");
        const scenarioId = formData.get("scenarioId");
        const customScenarioLineRaw = formData.get("customScenarioLine");
        const customScenarioLine =
          typeof customScenarioLineRaw === "string" ? customScenarioLineRaw.trim() : "";
        const practiceConfig = derivePracticeConfig(practiceType, durationMinutes);
        const durationConfig = deriveDurationConfig(durationMinutes);
        const primarySense = derivePrimarySense(focus, practiceConfig.eyeState);
        const senseRotation = deriveSenseRotation(practiceType, durationMinutes);
        const basePayload = {
          practiceMode: practiceConfig.practiceMode,
          bodyState: practiceConfig.bodyState,
          eyeState: practiceConfig.eyeState,
          primarySense,
          durationMinutes,
          labelingMode: practiceConfig.labelingMode,
          silenceProfile: durationConfig.silenceProfile,
          normalizationFrequency: durationConfig.normalizationFrequency,
          closingStyle: durationConfig.closingStyle,
          senseRotation,
          ...(scenarioId ? { scenarioId } : {}),
          languages: [language],
          voiceStyle,
          customScenarioLine: customScenarioLine || undefined,
          ttsNewlinePauseSeconds: Number(formData.get("ttsNewlinePauseSeconds")) || 0,
          ...(debugEnabled ? { debugTtsPrompt: true } : {}),
        };

        const buildTtsPayload = (script) => ({
          script,
          language,
          voice: voiceStyle,
          ttsNewlinePauseSeconds: Number(formData.get("ttsNewlinePauseSeconds")) || 0,
        });
        submitButton.disabled = true;
        statusPanel.hidden = false;
        spinner.hidden = false;
        status.textContent = translate("status.preparing");

        const requestJson = async (outputMode) => {
          const response = await fetch("/api/generate", {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
              Accept: "application/json",
              ...authHeaders,
            },
            body: JSON.stringify({ ...basePayload, outputMode }),
          });

          if (!response.ok) {
            const errorBody = await response.json();
            throw new Error(
              errorBody?.error?.message || translate("errors.generator_failed"),
            );
          }

          return response.json();
        };

        const requestStreamed = async () => {
          const response = await fetch("/api/generate", {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
              Accept: "text/event-stream",
              ...authHeaders,
            },
            body: JSON.stringify({ ...basePayload, outputMode: effectiveOutputMode }),
          });

          if (!response.ok) {
            const errorContentType = response.headers.get("content-type") || "";
            if (errorContentType.includes("application/json")) {
              const errorBody = await response.json();
              throw new Error(
                errorBody?.error?.message || translate("errors.generator_failed"),
              );
            }
            throw new Error(
              translate("errors.generator_failed_status", { status: response.status }),
            );
          }

          if (!response.body) {
            throw new Error(translate("errors.streaming_unavailable"));
          }

          const reader = response.body.getReader();
          const decoder = new TextDecoder();
          let buffer = "";
          let finalPayload = null;

          while (true) {
            const { value, done } = await reader.read();
            if (done) {
              break;
            }

            buffer += decoder.decode(value, { stream: true });
            let delimiterIndex = buffer.indexOf("\n\n");
            while (delimiterIndex !== -1) {
              const rawEvent = buffer.slice(0, delimiterIndex).trim();
              buffer = buffer.slice(delimiterIndex + 2);
              delimiterIndex = buffer.indexOf("\n\n");

              if (!rawEvent) {
                continue;
              }

              let eventType = "message";
              let data = "";
              for (const line of rawEvent.split("\n")) {
                if (line.startsWith("event:")) {
                  eventType = line.slice(6).trim();
                } else if (line.startsWith("data:")) {
                  data += line.slice(5).trim();
                }
              }

              if (eventType === "status") {
                status.textContent = data;
              } else if (eventType === "done") {
                finalPayload = JSON.parse(data);
              } else if (eventType === "error") {
                throw new Error(data || translate("errors.streaming_failed"));
              }
            }
          }

          if (!finalPayload) {
            throw new Error(translate("errors.stream_ended"));
          }

          return finalPayload;
        };

        const requestAudio = async (script, { onStreamStart, onChunk } = {}) => {
          const response = await fetch("/api/tts", {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
              Accept: "audio/wav",
              "x-tts-streaming": "1",
              ...authHeaders,
            },
            body: JSON.stringify(buildTtsPayload(script)),
          });

          if (!response.ok) {
            const errorContentType = response.headers.get("content-type") || "";
            if (errorContentType.includes("application/json")) {
              const errorBody = await response.json();
              throw new Error(
                errorBody?.error?.message || translate("errors.generator_failed"),
              );
            }
            throw new Error(
              translate("errors.generator_failed_status", { status: response.status }),
            );
          }

          const contentType = response.headers.get("content-type") || "audio/wav";
          if (!response.body) {
            const audioBuffer = await response.arrayBuffer();
            return { blob: new Blob([audioBuffer], { type: contentType }), contentType };
          }

          const reader = response.body.getReader();
          const chunks = [];
          const streamingMimeType = resolveStreamingMimeType(contentType);
          const canStream = typeof MediaSource !== "undefined";
          const canWebAudioStream =
            contentType.includes("audio/wav") && typeof AudioContext !== "undefined";

          if (canWebAudioStream) {
            await streamWavViaWebAudio({
              reader,
              onStreamStart: (mediaStream) =>
                onStreamStart?.({ mediaStream, contentType }),
              onChunk: (chunk) => {
                chunks.push(chunk);
                onChunk?.(chunk, { contentType });
              },
            });
            return { blob: new Blob(chunks, { type: contentType }), contentType };
          }

          if (canStream) {
            const mediaSource = new MediaSource();
            const mediaUrl = URL.createObjectURL(mediaSource);
            let streamStartNotified = false;
            const notifyStreamStart = () => {
              if (streamStartNotified) {
                return;
              }
              streamStartNotified = true;
              if (typeof onStreamStart === "function") {
                onStreamStart({ mediaUrl, contentType });
              }
            };

            try {
              notifyStreamStart();
              await new Promise((resolve, reject) => {
                const handleError = () =>
                  reject(new Error(translate("errors.audio_stream_failed")));

                mediaSource.addEventListener("error", handleError, { once: true });
                mediaSource.addEventListener(
                  "sourceopen",
                  async () => {
                    try {
                      const sourceBuffer = mediaSource.addSourceBuffer(streamingMimeType);
                      const appendChunk = (chunk) =>
                        new Promise((appendResolve, appendReject) => {
                          const onError = () =>
                            appendReject(new Error(translate("errors.append_audio_chunk_failed")));
                          const onUpdateEnd = () => appendResolve();
                          sourceBuffer.addEventListener("error", onError, { once: true });
                          sourceBuffer.addEventListener("updateend", onUpdateEnd, { once: true });
                          sourceBuffer.appendBuffer(chunk);
                        });

                      const firstRead = await reader.read();
                      if (firstRead.done || !firstRead.value) {
                        throw new Error(translate("errors.audio_stream_no_data"));
                      }
                      chunks.push(firstRead.value);
                      onChunk?.(firstRead.value, { contentType });
                      await appendChunk(firstRead.value);
                      notifyStreamStart();

                      while (true) {
                        const { value, done } = await reader.read();
                        if (done) {
                          break;
                        }
                        if (value) {
                          chunks.push(value);
                          onChunk?.(value, { contentType });
                          await appendChunk(value);
                        }
                      }

                      if (mediaSource.readyState === "open") {
                        mediaSource.endOfStream();
                      }
                      resolve();
                    } catch (streamError) {
                      reject(streamError);
                    }
                  },
                  { once: true },
                );
              });

              return { blob: new Blob(chunks, { type: contentType }), mediaUrl, contentType };
            } catch (streamError) {
              console.warn("Falling back to buffered WAV playback.", streamError);
            }
          }

          while (true) {
            const { value, done } = await reader.read();
            if (done) {
              break;
            }
            if (value) {
              chunks.push(value);
              onChunk?.(value, { contentType });
            }
          }
          return { blob: new Blob(chunks, { type: contentType }), contentType };
        };

        try {
          let script = "";
          let audioBlob = null;
          let ttsPrompt = null;
          let streamUrl = null;

        if (streamAudioEnabled) {
          const jsonResponse = await requestJson("text");
          script = jsonResponse?.script || "";
          ttsPrompt = jsonResponse?.ttsPrompt || null;
          const cleanedScript = script
            ? script.replace(/\[pause:\d+(?:\.\d+)?\]/g, "").trim()
            : "";
          if (cleanedScript) {
            scriptOutput.textContent = cleanedScript;
            scriptOutput.hidden = false;
            if (scriptDownloadUrl) {
              URL.revokeObjectURL(scriptDownloadUrl);
            }
            scriptDownloadUrl = URL.createObjectURL(
              new Blob([cleanedScript], { type: "text/plain" }),
            );
            scriptDownloadLink.download = buildScriptDownloadFilename({
              voice: voiceStyle,
              durationMinutes,
              focus: primarySense,
            });
            setDownloadLinkState(scriptDownloadLink, { enabled: true, href: scriptDownloadUrl });
          }
          result.hidden = false;
          const streamingChunks = [];
          let streamContentType = null;
          const enableDownloadFromChunks = () => {
            if (!streamingChunks.length) {
              return;
            }
            if (downloadUrl) {
              URL.revokeObjectURL(downloadUrl);
            }
            const partialBlob = new Blob(streamingChunks, {
              type: streamContentType || "audio/wav",
            });
            downloadUrl = URL.createObjectURL(partialBlob);
            downloadLink.download = buildDownloadFilename({
              voice: voiceStyle,
              durationMinutes,
              focus: primarySense,
              extension: resolveAudioExtension(streamContentType || partialBlob.type),
            });
            setDownloadLinkState(downloadLink, { enabled: true, href: downloadUrl });
          };
            const streamResponse = await requestAudio(script, {
              onStreamStart: ({ mediaUrl, mediaStream, contentType: streamResponseContentType }) => {
                streamUrl = mediaUrl;
                streamContentType = streamResponseContentType;
                if (mediaStream) {
                  audioPlayer.srcObject = mediaStream;
                  audioPlayer.play().catch(() => {});
                  audioPlayer.hidden = false;
                } else if (mediaUrl) {
                  audioPlayer.srcObject = null;
                  audioPlayer.src = mediaUrl;
                  audioPlayer.play().catch(() => {});
                  audioPlayer.hidden = false;
                }
                status.textContent = "";
                statusPanel.hidden = true;
                spinner.hidden = true;
                const downloadFilename = buildDownloadFilename({
                  voice: voiceStyle,
                  durationMinutes,
                  focus: primarySense,
                  extension: resolveAudioExtension(streamResponseContentType),
                });
                downloadLink.download = downloadFilename;
                setDownloadLinkState(downloadLink, { enabled: false });
                result.hidden = false;
              },
              onChunk: (chunk, { contentType }) => {
                streamingChunks.push(chunk);
                if (!streamContentType && contentType) {
                  streamContentType = contentType;
                }
                if (streamingChunks.length === 1) {
                  enableDownloadFromChunks();
                }
              },
            });
            audioBlob = streamResponse?.blob || null;
            if (streamResponse?.mediaUrl) {
              streamUrl = streamResponse.mediaUrl;
            } else if (streamUrl) {
              URL.revokeObjectURL(streamUrl);
              streamUrl = null;
            }
            const extension = resolveAudioExtension(streamResponse?.contentType);
            downloadLink.download = buildDownloadFilename({
              voice: voiceStyle,
              durationMinutes,
              focus: primarySense,
              extension,
            });
            script = jsonResponse?.script || "";
            ttsPrompt = jsonResponse?.ttsPrompt || null;
          } else {
            const jsonResponse = await requestJson(effectiveOutputMode);
            script = jsonResponse?.script || "";
            ttsPrompt = jsonResponse?.ttsPrompt || null;
            if (effectiveOutputMode === "text-audio" && jsonResponse?.audioBase64) {
              const binary = atob(jsonResponse.audioBase64);
              const bytes = new Uint8Array(binary.length);
              for (let index = 0; index < binary.length; index += 1) {
                bytes[index] = binary.charCodeAt(index);
              }
              audioBlob = new Blob([bytes], {
                type: jsonResponse?.audioContentType || "audio/wav",
              });
            }
          }

          if (audioBlob) {
            if (currentUrl) {
              URL.revokeObjectURL(currentUrl);
            }
            if (downloadUrl) {
              URL.revokeObjectURL(downloadUrl);
            }
            downloadUrl = URL.createObjectURL(audioBlob);
            currentUrl = streamUrl || downloadUrl;
            if (audioPlayer.src !== currentUrl) {
              audioPlayer.srcObject = null;
              audioPlayer.src = currentUrl;
            }
            audioPlayer.hidden = false;
            downloadLink.href = downloadUrl;
            downloadLink.download = buildDownloadFilename({
              voice: voiceStyle,
              durationMinutes,
              focus: primarySense,
              extension: resolveAudioExtension(audioBlob.type),
            });
            setDownloadLinkState(downloadLink, { enabled: true, href: downloadUrl });
          } else {
            audioPlayer.hidden = true;
            setDownloadLinkState(downloadLink, { enabled: false });
          }

          const cleanedScript = script ? script.replace(/\[pause:\d+(?:\.\d+)?\]/g, "").trim() : "";

          if (cleanedScript) {
            scriptOutput.textContent = cleanedScript;
            scriptOutput.hidden = false;
            if (scriptDownloadUrl) {
              URL.revokeObjectURL(scriptDownloadUrl);
            }
            scriptDownloadUrl = URL.createObjectURL(new Blob([cleanedScript], { type: "text/plain" }));
            scriptDownloadLink.download = buildScriptDownloadFilename({
              voice: voiceStyle,
              durationMinutes,
              focus: primarySense,
            });
            setDownloadLinkState(scriptDownloadLink, { enabled: true, href: scriptDownloadUrl });
          } else {
            scriptOutput.hidden = true;
            setDownloadLinkState(scriptDownloadLink, { enabled: false });
          }

          if (ttsPrompt) {
            debugOutput.textContent = JSON.stringify(ttsPrompt, null, 2);
            debugSection.hidden = false;
          } else {
            debugSection.hidden = true;
          }

          result.hidden = false;
          status.textContent = "";
          statusPanel.hidden = true;
          spinner.hidden = true;
        } catch (err) {
          error.hidden = false;
          error.textContent = err instanceof Error ? err.message : translate("errors.unknown");
          status.textContent = "";
          spinner.hidden = true;
        } finally {
          submitButton.disabled = false;
        }
      });
    </script>
  </body>
</html>
