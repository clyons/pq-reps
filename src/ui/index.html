<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>PQ Reps Audio Generator</title>
    <style>
      body {
        font-family: "Inter", system-ui, sans-serif;
        background: #f5f5f5;
        margin: 0;
        padding: 2rem;
        color: #1f1f1f;
      }
      main {
        max-width: 720px;
        margin: 0 auto;
        background: #fff;
        padding: 2rem;
        border-radius: 16px;
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.08);
      }
      h1 {
        margin-top: 0;
      }
      .version {
        margin-top: -0.25rem;
        color: #666;
        font-size: 0.9rem;
      }
      form {
        display: grid;
        gap: 1.5rem;
      }
      label {
        display: grid;
        gap: 0.5rem;
        font-weight: 600;
      }
      input,
      select {
        padding: 0.75rem;
        border-radius: 8px;
        border: 1px solid #ccc;
        font-size: 1rem;
      }
      button {
        padding: 0.85rem 1.5rem;
        background: #111;
        color: #fff;
        border: none;
        border-radius: 999px;
        font-weight: 600;
        cursor: pointer;
      }
      .button-secondary {
        background: #e5e5e5;
        color: #111;
      }
      button[disabled] {
        cursor: not-allowed;
        background: #888;
      }
      .status-panel {
        margin-top: 1.5rem;
        padding: 1rem;
        border-radius: 12px;
        background: #f0f4ff;
        border: 1px solid #d5ddf7;
        display: grid;
        gap: 0.5rem;
      }
      .status-row {
        display: flex;
        align-items: center;
        gap: 0.75rem;
      }
      .spinner {
        width: 18px;
        height: 18px;
        border-radius: 50%;
        border: 3px solid #c3c9f7;
        border-top-color: #3545a3;
        animation: spin 0.9s linear infinite;
      }
      .spinner[hidden] {
        display: none;
      }
      .status {
        margin: 0;
        color: #2a2f4a;
        font-weight: 600;
      }
      .progress-list {
        margin: 0.5rem 0 0;
        padding-left: 1.25rem;
        color: #444;
      }
      .progress-list li {
        margin: 0.25rem 0;
      }
      .error {
        background: #ffecec;
        color: #b30000;
        padding: 1rem;
        border-radius: 8px;
      }
      .result {
        margin-top: 2rem;
        background: #f7f7f7;
        padding: 1.5rem;
        border-radius: 12px;
      }
      .debug-prompt {
        margin-top: 1.5rem;
        background: #111;
        color: #f5f5f5;
        padding: 1rem;
        border-radius: 8px;
        white-space: pre-wrap;
        word-break: break-word;
      }
      .hint {
        font-weight: 400;
        color: #555;
        font-size: 0.9rem;
      }
      .download-link {
        display: inline-flex;
        margin-top: 0.75rem;
        font-weight: 600;
        color: #0f2d81;
        text-decoration: none;
      }
      @keyframes spin {
        to {
          transform: rotate(360deg);
        }
      }
    </style>
  </head>
  <body>
    <main>
      <h1>PQ Reps Audio Generator</h1>
      <p id="app-version" class="version">Version: loading...</p>
      <p>
        Create guided PQ Reps that sharpen the PQ brain with tactile, breath, or visual focus.
        Pick how you are practicing (for example, tactile PQ reps) and set how long the rep
        should run.
      </p>

      <form id="generator-form">
        <label>
          Practice Mode
          <select name="practiceMode" required>
            <option value="tactile">Tactile</option>
            <option value="tense_relax">Tense + Relax</option>
            <option value="moving">Moving</option>
            <option value="sitting">Sitting</option>
            <option value="label_with_anchor">Label with Anchor</option>
            <option value="label_while_scanning">Label While Scanning</option>
          </select>
        </label>

        <label>
          Body State
          <select name="bodyState" required>
            <option value="still_seated">Still seated</option>
            <option value="still_seated_closed_eyes">Still seated, eyes closed</option>
            <option value="moving">Moving</option>
          </select>
        </label>

        <label>
          Eye State
          <select name="eyeState" required>
            <option value="closed">Closed</option>
            <option value="open_focused">Open, focused</option>
            <option value="open_diffused">Open, diffused</option>
          </select>
        </label>

        <label>
          Primary Sense
          <select name="primarySense" required>
            <option value="touch">Touch</option>
            <option value="hearing">Hearing</option>
            <option value="sight">Sight</option>
            <option value="breath">Breath</option>
            <option value="body_weight">Body weight</option>
            <option value="smell">Smell</option>
            <option value="taste">Taste</option>
          </select>
        </label>

        <label>
          Duration: <span id="duration-label">2 minutes</span>
          <select name="durationMinutes" required>
            <option value="1">1 minute</option>
            <option value="2">2 minutes</option>
            <option value="5">5 minutes</option>
            <option value="12">12 minutes</option>
          </select>
        </label>

        <label>
          Labeling Mode
          <select name="labelingMode" required>
            <option value="none">None</option>
            <option value="breath_anchor">Breath anchor</option>
            <option value="scan_and_label">Scan and label</option>
          </select>
        </label>

        <label>
          Silence Profile
          <select name="silenceProfile" required>
            <option value="none">None</option>
            <option value="short_pauses">Short pauses</option>
            <option value="extended_silence">Extended silence</option>
          </select>
        </label>

        <label>
          Normalization Frequency
          <select name="normalizationFrequency" required>
            <option value="once">Once</option>
            <option value="periodic">Periodic</option>
            <option value="repeated">Repeated</option>
          </select>
        </label>

        <label>
          Closing Style
          <select name="closingStyle" required>
            <option value="minimal">Minimal</option>
            <option value="pq_framed">PQ framed</option>
            <option value="pq_framed_with_progression">PQ framed with progression</option>
          </select>
        </label>

        <label>
          Sense Rotation
          <select name="senseRotation">
            <option value="none">None</option>
            <option value="guided_rotation">Guided rotation</option>
            <option value="free_choice">Free choice</option>
          </select>
        </label>

        <label>
          Language
          <select name="language" required>
            <option value="en">English</option>
            <option value="es">Spanish</option>
            <option value="fr">French</option>
            <option value="de">German</option>
          </select>
        </label>

        <label>
          Output
          <select name="outputMode">
            <option value="text">Text only</option>
            <option value="audio" selected>Audio only</option>
            <option value="text-audio">Text + audio</option>
          </select>
        </label>

        <label>
          TTS newline pause (seconds)
          <input type="number" name="ttsNewlinePauseSeconds" min="0" step="0.5" value="1" />
        </label>

        <label>
          <span>Debug TTS prompt</span>
          <span class="hint">Include the raw TTS payload for OpenAI playground testing.</span>
          <input type="checkbox" name="debugTtsPrompt" />
        </label>

        <label>
          <span>Debug TTS prompt</span>
          <span class="hint">Include the raw TTS payload for OpenAI playground testing.</span>
          <input type="checkbox" name="debugTtsPrompt" />
        </label>

        <div style="display: flex; gap: 0.75rem; flex-wrap: wrap;">
          <button type="submit" id="submit-button">Generate audio</button>
          <button type="button" id="reset-button" class="button-secondary">
            Reset to defaults
          </button>
        </div>
      </form>

      <section id="status-panel" class="status-panel" hidden>
        <div class="status-row">
          <span id="spinner" class="spinner" aria-hidden="true"></span>
          <p class="status" id="status" aria-live="polite"></p>
        </div>
        <ol id="progress-list" class="progress-list" hidden></ol>
      </section>
      <div id="error" class="error" hidden></div>

      <section id="result" class="result" hidden>
        <h2>Your session is ready</h2>
        <audio id="audio-player" controls style="width: 100%;" hidden></audio>
        <a id="download-link" class="download-link" download="pq-reps.wav" hidden>
          Download the WAV
        </a>
        <p id="script-output" style="margin-top: 1rem; white-space: pre-line;" hidden></p>
        <div id="debug-section" hidden>
          <h3>TTS prompt (debug)</h3>
          <pre id="debug-output" class="debug-prompt"></pre>
        </div>
      </section>
    </main>

    <script>
      const form = document.getElementById("generator-form");
      const durationInput = form.querySelector("select[name='durationMinutes']");
      const durationLabel = document.getElementById("duration-label");
      const status = document.getElementById("status");
      const statusPanel = document.getElementById("status-panel");
      const spinner = document.getElementById("spinner");
      const error = document.getElementById("error");
      const result = document.getElementById("result");
      const audioPlayer = document.getElementById("audio-player");
      const downloadLink = document.getElementById("download-link");
      const scriptOutput = document.getElementById("script-output");
      const submitButton = document.getElementById("submit-button");
      const progressList = document.getElementById("progress-list");
      const debugInput = form.querySelector("input[name='debugTtsPrompt']");
      const appVersion = document.getElementById("app-version");
      const resetButton = document.getElementById("reset-button");
      const debugSection = document.getElementById("debug-section");
      const debugOutput = document.getElementById("debug-output");
      let currentUrl = null;
      const storageKey = "pq-reps-form";

      const updateDurationLabel = () => {
        const minutes = Number(durationInput.value);
        durationLabel.textContent = `${minutes} minute${minutes === 1 ? "" : "s"}`;
      };

      const resetProgress = () => {
        progressList.innerHTML = "";
        progressList.hidden = true;
      };

      const addProgressStep = (message) => {
        const item = document.createElement("li");
        item.textContent = message;
        progressList.appendChild(item);
        progressList.hidden = false;
      };

      const getFormValues = () => {
        const formData = new FormData(form);
        return Object.fromEntries(formData.entries());
      };

      const setFormValues = (values) => {
        Object.entries(values).forEach(([name, value]) => {
          const field = form.elements.namedItem(name);
          if (field && "value" in field && value != null) {
            field.value = value;
          }
        });
        updateDurationLabel();
      };

      const defaultValues = getFormValues();

      const storedValuesRaw = localStorage.getItem(storageKey);
      if (storedValuesRaw) {
        try {
          const storedValues = JSON.parse(storedValuesRaw);
          if (storedValues && typeof storedValues === "object") {
            setFormValues(storedValues);
          }
        } catch (err) {
          localStorage.removeItem(storageKey);
        }
      }

      updateDurationLabel();
      durationInput.addEventListener("change", updateDurationLabel);

      const loadVersion = async () => {
        if (!appVersion) {
          return;
        }
        try {
          const response = await fetch("/version");
          if (!response.ok) {
            throw new Error("Version unavailable.");
          }
          const data = await response.json();
          appVersion.textContent = `Version: ${data?.version || "unknown"}`;
        } catch (err) {
          appVersion.textContent = "Version: unavailable";
        }
      };

      loadVersion();
      resetButton.addEventListener("click", () => {
        setFormValues(defaultValues);
        localStorage.removeItem(storageKey);
      });

      form.addEventListener("submit", async (event) => {
        event.preventDefault();
        error.hidden = true;
        error.textContent = "";
        status.textContent = "";
        statusPanel.hidden = true;
        spinner.hidden = true;
        resetProgress();
        result.hidden = true;
        scriptOutput.textContent = "";
        debugOutput.textContent = "";
        debugSection.hidden = true;

        if (currentUrl) {
          URL.revokeObjectURL(currentUrl);
          currentUrl = null;
        }

        const formData = new FormData(form);
        localStorage.setItem(storageKey, JSON.stringify(Object.fromEntries(formData.entries())));
        const outputMode = formData.get("outputMode");
        const debugEnabled = debugInput.checked;
        const effectiveOutputMode =
          debugEnabled && outputMode !== "text-audio" ? "text-audio" : outputMode;
        const payload = {
          practiceMode: formData.get("practiceMode"),
          bodyState: formData.get("bodyState"),
          eyeState: formData.get("eyeState"),
          primarySense: formData.get("primarySense"),
          durationMinutes: Number(formData.get("durationMinutes")),
          labelingMode: formData.get("labelingMode"),
          silenceProfile: formData.get("silenceProfile"),
          normalizationFrequency: formData.get("normalizationFrequency"),
          closingStyle: formData.get("closingStyle"),
          senseRotation: formData.get("senseRotation") || undefined,
          languages: [formData.get("language")],
          ttsNewlinePauseSeconds: Number(formData.get("ttsNewlinePauseSeconds")) || 0,
          outputMode: effectiveOutputMode,
          debugTtsPrompt: debugEnabled,
        };
        const streamingEnabled = true;

        submitButton.disabled = true;
        statusPanel.hidden = false;
        spinner.hidden = false;
        status.textContent = "Generating audio. This can take a few seconds.";

        const requestJson = async () => {
          const response = await fetch("/api/generate", {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
              Accept: "application/json",
            },
            body: JSON.stringify(payload),
          });

          if (!response.ok) {
            const errorBody = await response.json();
            throw new Error(errorBody?.error?.message || "The generator failed to respond.");
          }

          return response.json();
        };

        const requestStreamed = async () => {
          const response = await fetch("/api/generate", {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
              Accept: "text/event-stream",
            },
            body: JSON.stringify(payload),
          });

          if (!response.ok) {
            const errorContentType = response.headers.get("content-type") || "";
            if (errorContentType.includes("application/json")) {
              const errorBody = await response.json();
              throw new Error(errorBody?.error?.message || "The generator failed to respond.");
            }
            throw new Error(`The generator failed to respond. (${response.status})`);
          }

          if (!response.body) {
            throw new Error("Streaming updates are not available.");
          }

          const reader = response.body.getReader();
          const decoder = new TextDecoder();
          let buffer = "";
          let finalPayload = null;

          while (true) {
            const { value, done } = await reader.read();
            if (done) {
              break;
            }

            buffer += decoder.decode(value, { stream: true });
            let delimiterIndex = buffer.indexOf("\n\n");
            while (delimiterIndex !== -1) {
              const rawEvent = buffer.slice(0, delimiterIndex).trim();
              buffer = buffer.slice(delimiterIndex + 2);
              delimiterIndex = buffer.indexOf("\n\n");

              if (!rawEvent) {
                continue;
              }

              let eventType = "message";
              let data = "";
              for (const line of rawEvent.split("\n")) {
                if (line.startsWith("event:")) {
                  eventType = line.slice(6).trim();
                } else if (line.startsWith("data:")) {
                  data += line.slice(5).trim();
                }
              }

              if (eventType === "status") {
                addProgressStep(data);
                status.textContent = data;
              } else if (eventType === "done") {
                finalPayload = JSON.parse(data);
              } else if (eventType === "error") {
                throw new Error(data || "Streaming failed.");
              }
            }
          }

          if (!finalPayload) {
            throw new Error("The stream ended before returning a response.");
          }

          return finalPayload;
        };

        const requestAudio = async () => {
          const response = await fetch("/api/generate", {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
              Accept: "audio/wav",
            },
            body: JSON.stringify(payload),
          });

          if (!response.ok) {
            const errorContentType = response.headers.get("content-type") || "";
            if (errorContentType.includes("application/json")) {
              const errorBody = await response.json();
              throw new Error(errorBody?.error?.message || "The generator failed to respond.");
            }
            throw new Error(`The generator failed to respond. (${response.status})`);
          }

          const audioBuffer = await response.arrayBuffer();
          const contentType = response.headers.get("content-type") || "audio/wav";
          return new Blob([audioBuffer], { type: contentType });
        };

        try {
          let script = "";
          let audioBlob = null;
          let ttsPrompt = null;

          if (streamingEnabled) {
            const streamedResponse = await requestStreamed();
            script = streamedResponse?.script || "";
            ttsPrompt = streamedResponse?.ttsPrompt || null;
            if (streamedResponse?.audioBase64) {
              const binary = atob(streamedResponse.audioBase64);
              const bytes = new Uint8Array(binary.length);
              for (let index = 0; index < binary.length; index += 1) {
                bytes[index] = binary.charCodeAt(index);
              }
              audioBlob = new Blob([bytes], {
                type: streamedResponse?.audioContentType || "audio/wav",
              });
            }
          } else if (effectiveOutputMode === "audio") {
            audioBlob = await requestAudio();
          } else {
            const jsonResponse = await requestJson();
            script = jsonResponse?.script || "";
            ttsPrompt = jsonResponse?.ttsPrompt || null;
            if (effectiveOutputMode === "text-audio" && jsonResponse?.audioBase64) {
              const binary = atob(jsonResponse.audioBase64);
              const bytes = new Uint8Array(binary.length);
              for (let index = 0; index < binary.length; index += 1) {
                bytes[index] = binary.charCodeAt(index);
              }
              audioBlob = new Blob([bytes], {
                type: jsonResponse?.audioContentType || "audio/wav",
              });
            }
          }

          if (audioBlob) {
            currentUrl = URL.createObjectURL(audioBlob);
            audioPlayer.src = currentUrl;
            audioPlayer.hidden = false;
            downloadLink.href = currentUrl;
            downloadLink.hidden = false;
          } else {
            audioPlayer.hidden = true;
            downloadLink.hidden = true;
          }

          if (script) {
            scriptOutput.textContent = script;
            scriptOutput.hidden = false;
          } else {
            scriptOutput.hidden = true;
          }

          if (ttsPrompt) {
            debugOutput.textContent = JSON.stringify(ttsPrompt, null, 2);
            debugSection.hidden = false;
          } else {
            debugSection.hidden = true;
          }

          result.hidden = false;
          status.textContent =
            effectiveOutputMode === "text" ? "Text ready!" : "Output ready!";
          spinner.hidden = true;
        } catch (err) {
          error.hidden = false;
          error.textContent = err instanceof Error ? err.message : "Something went wrong.";
          status.textContent = "";
          spinner.hidden = true;
        } finally {
          submitButton.disabled = false;
        }
      });
    </script>
  </body>
</html>
