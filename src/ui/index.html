<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>PQ Reps Audio Generator</title>
    <style>
      body {
        font-family: "Inter", system-ui, sans-serif;
        background: #f5f5f5;
        margin: 0;
        padding: 2rem;
        color: #1f1f1f;
      }
      main {
        max-width: 720px;
        margin: 0 auto;
        background: #fff;
        padding: 2rem;
        border-radius: 16px;
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.08);
      }
      h1 {
        margin-top: 0;
      }
      .version {
        margin-top: -0.25rem;
        color: #666;
        font-size: 0.9rem;
      }
      form {
        display: grid;
        gap: 1.5rem;
      }
      label {
        display: grid;
        gap: 0.5rem;
        font-weight: 600;
      }
      input {
        padding: 0.75rem;
        border-radius: 8px;
        border: 1px solid #ccc;
        font-size: 1rem;
      }
      .pill-group {
        display: flex;
        flex-wrap: wrap;
        gap: 0.5rem;
      }
      .pill-option {
        position: relative;
      }
      .pill-option input {
        position: absolute;
        opacity: 0;
        pointer-events: none;
      }
      .pill {
        display: inline-flex;
        align-items: center;
        padding: 0.5rem 0.9rem;
        border-radius: 999px;
        border: 1px solid #ccc;
        background: #f7f7f7;
        font-weight: 600;
        cursor: pointer;
        transition: all 0.15s ease;
      }
      .pill-option input:checked + .pill {
        background: #111;
        border-color: #111;
        color: #fff;
      }
      .pill-option input:focus-visible + .pill {
        outline: 2px solid #3545a3;
        outline-offset: 2px;
      }
      .pill-option input:disabled + .pill {
        opacity: 0.5;
        cursor: not-allowed;
      }
      button {
        padding: 0.85rem 1.5rem;
        background: #111;
        color: #fff;
        border: none;
        border-radius: 999px;
        font-weight: 600;
        cursor: pointer;
      }
      .button-secondary {
        background: #e5e5e5;
        color: #111;
      }
      button[disabled] {
        cursor: not-allowed;
        background: #888;
      }
      .status-panel {
        margin-top: 1.5rem;
        padding: 1rem;
        border-radius: 12px;
        background: #f0f4ff;
        border: 1px solid #d5ddf7;
        display: grid;
        gap: 0.5rem;
      }
      .status-panel[hidden] {
        display: none;
      }
      .status-row {
        display: flex;
        align-items: center;
        gap: 0.75rem;
      }
      .spinner {
        width: 18px;
        height: 18px;
        border-radius: 50%;
        border: 3px solid #c3c9f7;
        border-top-color: #3545a3;
        animation: spin 0.9s linear infinite;
      }
      .spinner[hidden] {
        display: none;
      }
      .status {
        margin: 0;
        color: #2a2f4a;
        font-weight: 600;
      }
      .progress-list {
        margin: 0.5rem 0 0;
        padding-left: 1.25rem;
        color: #444;
      }
      .progress-list li {
        margin: 0.25rem 0;
      }
      .error {
        background: #ffecec;
        color: #b30000;
        padding: 1rem;
        border-radius: 8px;
      }
      .result {
        margin-top: 2rem;
        background: #f7f7f7;
        padding: 1.5rem;
        border-radius: 12px;
      }
      .debug-prompt {
        margin-top: 1.5rem;
        background: #111;
        color: #f5f5f5;
        padding: 1rem;
        border-radius: 8px;
        white-space: pre-wrap;
        word-break: break-word;
      }
      .hint {
        font-weight: 400;
        color: #555;
        font-size: 0.9rem;
      }
      .download-link {
        display: inline-flex;
        margin-top: 0.75rem;
        font-weight: 600;
        color: #0f2d81;
        text-decoration: none;
      }
      .option-hint {
        font-weight: 400;
        color: #555;
        font-size: 0.9rem;
      }
      .footer {
        margin-top: 2.5rem;
        padding-top: 1.25rem;
        border-top: 1px solid #e5e5e5;
        color: #666;
        font-size: 0.9rem;
        line-height: 1.5;
      }
      @keyframes spin {
        to {
          transform: rotate(360deg);
        }
      }
    </style>
  </head>
  <body>
    <main>
      <h1>PQ Reps Audio Generator</h1>
      <p id="app-version" class="version">Version: loading...</p>
      <p>Choose the type of PQ Reps you'd like to practice.</p>
      <p>Audio is AI-generated.</p>

      <form id="generator-form">
        <label>
          Practice type
          <div class="pill-group" role="radiogroup" aria-label="Practice type">
            <label class="pill-option">
              <input type="radio" name="practiceType" value="still_eyes_closed" checked required />
              <span class="pill">Still (Eyes closed)</span>
            </label>
            <label class="pill-option">
              <input type="radio" name="practiceType" value="still_eyes_open" />
              <span class="pill">Still (Eyes open)</span>
            </label>
            <label class="pill-option">
              <input type="radio" name="practiceType" value="moving" />
              <span class="pill">Moving</span>
            </label>
            <label class="pill-option">
              <input type="radio" name="practiceType" value="labeling" />
              <span class="pill">Labeling</span>
            </label>
          </div>
        </label>

        <label>
          Focus
          <div class="pill-group" role="radiogroup" aria-label="Focus">
            <label class="pill-option">
              <input type="radio" name="focus" value="touch" checked required />
              <span class="pill">Touch</span>
            </label>
            <label class="pill-option">
              <input type="radio" name="focus" value="hearing" />
              <span class="pill">Hearing</span>
            </label>
            <label class="pill-option">
              <input type="radio" name="focus" value="sight" />
              <span class="pill">Sight</span>
            </label>
            <label class="pill-option">
              <input type="radio" name="focus" value="breath" />
              <span class="pill">Breath</span>
            </label>
          </div>
        </label>

        <label>
          Duration
          <div class="pill-group" role="radiogroup" aria-label="Duration">
            <label class="pill-option">
              <input type="radio" name="durationMinutes" value="1" checked required />
              <span class="pill">1 minute</span>
            </label>
            <label class="pill-option">
              <input type="radio" name="durationMinutes" value="2" />
              <span class="pill">2 minutes</span>
            </label>
            <label class="pill-option">
              <input type="radio" name="durationMinutes" value="5" />
              <span class="pill">5 minutes</span>
            </label>
            <label class="pill-option">
              <input type="radio" name="durationMinutes" value="12" />
              <span class="pill">12 minutes</span>
            </label>
          </div>
        </label>

        <label>
          Language
          <div class="pill-group" role="radiogroup" aria-label="Language">
            <label class="pill-option">
              <input type="radio" name="language" value="en" checked required />
              <span class="pill">English</span>
            </label>
            <label class="pill-option">
              <input type="radio" name="language" value="es" />
              <span class="pill">Spanish</span>
            </label>
            <label class="pill-option">
              <input type="radio" name="language" value="fr" />
              <span class="pill">French</span>
            </label>
            <label class="pill-option">
              <input type="radio" name="language" value="de" />
              <span class="pill">German</span>
            </label>
          </div>
        </label>

        <label>
          Voice
          <div class="pill-group" role="radiogroup" aria-label="Voice">
            <label class="pill-option">
              <input type="radio" name="voiceGender" value="male" required />
              <span class="pill">Male</span>
            </label>
            <label class="pill-option">
              <input type="radio" name="voiceGender" value="female" checked />
              <span class="pill">Female</span>
            </label>
          </div>
          <span class="option-hint">Choose the voice you prefer for guidance.</span>
        </label>

        <label>
          Audio delivery
          <div style="display: flex; align-items: center; gap: 0.5rem;">
            <input type="checkbox" name="streamAudio" id="stream-audio" />
            <label for="stream-audio" class="option-hint" style="margin: 0;">
              Stream audio as it is generated
            </label>
          </div>
          <span class="option-hint">
            Streaming starts playback sooner but can be less reliable on spotty connections and may limit seeking or offline replay.
          </span>
        </label>

        <div id="dev-controls" hidden>
          <label>
            TTS newline pause (seconds)
            <input type="number" name="ttsNewlinePauseSeconds" min="0" step="0.5" value="1.5" />
          </label>

          <label>
            <span>Debug TTS prompt</span>
            <span class="hint">Include the raw TTS payload for OpenAI playground testing.</span>
            <input type="checkbox" name="debugTtsPrompt" />
          </label>
        </div>

        <div style="display: flex; gap: 0.75rem; flex-wrap: wrap;">
          <button type="submit" id="submit-button">Generate</button>
          <button type="button" id="reset-button" class="button-secondary">
            Reset to defaults
          </button>
        </div>
      </form>

      <section id="status-panel" class="status-panel" hidden>
        <div class="status-row">
          <span id="spinner" class="spinner" aria-hidden="true"></span>
          <p class="status" id="status" aria-live="polite"></p>
        </div>
      </section>
      <div id="error" class="error" hidden></div>

      <section id="result" class="result" hidden>
        <h2>Your session is ready</h2>
        <audio id="audio-player" controls style="width: 100%;" hidden></audio>
        <a id="download-link" class="download-link" download="pq-reps.wav" hidden>
          Download the WAV
        </a>
        <a id="script-download-link" class="download-link" download="pq-reps.txt" hidden>
          Download the script
        </a>
        <p id="script-output" style="margin-top: 1rem; white-space: pre-line;" hidden></p>
        <div id="debug-section" hidden>
          <h3>TTS prompt (debug)</h3>
          <pre id="debug-output" class="debug-prompt"></pre>
        </div>
      </section>

      <footer class="footer">
        Inspired by publicly available teachings on Positive Intelligence® and PQ Reps® by Shirzad
        Chamine. Not affiliated with or endorsed by Positive Intelligence LLC. For educational
        purposes only.
      </footer>
    </main>

    <script>
      const form = document.getElementById("generator-form");
      const practiceTypeInputs = form.querySelectorAll("input[name='practiceType']");
      const durationInputs = form.querySelectorAll("input[name='durationMinutes']");
      const getSelectedValue = (name) =>
        form.querySelector(`input[name='${name}']:checked`)?.value;
      const status = document.getElementById("status");
      const statusPanel = document.getElementById("status-panel");
      const spinner = document.getElementById("spinner");
      const error = document.getElementById("error");
      const result = document.getElementById("result");
      const audioPlayer = document.getElementById("audio-player");
      const downloadLink = document.getElementById("download-link");
      const scriptDownloadLink = document.getElementById("script-download-link");
      const scriptOutput = document.getElementById("script-output");
      const submitButton = document.getElementById("submit-button");
      const debugInput = form.querySelector("input[name='debugTtsPrompt']");
      const streamAudioInput = form.querySelector("input[name='streamAudio']");
      const appVersion = document.getElementById("app-version");
      const resetButton = document.getElementById("reset-button");
      const debugSection = document.getElementById("debug-section");
      const debugOutput = document.getElementById("debug-output");
      const devControls = document.getElementById("dev-controls");
      let currentUrl = null;
      let downloadUrl = null;
      let scriptDownloadUrl = null;
      const storageKey = "pq-reps-form";
      const femaleVoiceByLanguage = { es: "nova", fr: "nova" };
      const maleVoiceByLanguage = { es: "onyx", fr: "onyx" };
      const isDevMode = new URLSearchParams(window.location.search).get("dev") === "1";

      if (devControls) {
        devControls.hidden = !isDevMode;
      }

      const derivePracticeConfig = (practiceType, durationMinutes) => {
        if (practiceType === "still_eyes_closed") {
          return {
            practiceMode: "tactile",
            bodyState: "still_seated_closed_eyes",
            eyeState: "closed",
            labelingMode: "none",
          };
        }
        if (practiceType === "still_eyes_open") {
          return {
            practiceMode: "sitting",
            bodyState: "still_seated",
            eyeState: "open_diffused",
            labelingMode: "none",
          };
        }
        if (practiceType === "moving") {
          return {
            practiceMode: "moving",
            bodyState: "moving",
            eyeState: "open_focused",
            labelingMode: "none",
          };
        }
        const labelingMode = durationMinutes < 5 ? "breath_anchor" : "scan_and_label";
        return {
          practiceMode: durationMinutes < 5 ? "label_with_anchor" : "label_while_scanning",
          bodyState: "still_seated_closed_eyes",
          eyeState: "closed",
          labelingMode,
        };
      };

      const deriveDurationConfig = (durationMinutes) => {
        if (durationMinutes === 1 || durationMinutes === 2) {
          return {
            silenceProfile: "none",
            normalizationFrequency: "once",
            closingStyle: "minimal",
          };
        }
        if (durationMinutes === 5) {
          return {
            silenceProfile: "short_pauses",
            normalizationFrequency: "periodic",
            closingStyle: "pq_framed",
          };
        }
        return {
          silenceProfile: "extended_silence",
          normalizationFrequency: "repeated",
          closingStyle: "pq_framed_with_progression",
        };
      };

      const deriveSenseRotation = (practiceType, durationMinutes) => {
        if (durationMinutes >= 5 && practiceType !== "labeling") {
          return "guided_rotation";
        }
        return "none";
      };

      const formatTimestamp = (date) => {
        const year = date.getFullYear();
        const month = String(date.getMonth() + 1).padStart(2, "0");
        const day = String(date.getDate()).padStart(2, "0");
        const hour = String(date.getHours()).padStart(2, "0");
        const minute = String(date.getMinutes()).padStart(2, "0");
        return `${year}${month}${day}-${hour}${minute}`;
      };

      const buildDownloadFilename = ({
        voice,
        durationMinutes,
        focus,
        now = new Date(),
        extension = "wav",
      }) => `pq-reps_${voice}_${durationMinutes}_${focus}_${formatTimestamp(now)}.${extension}`;

      const resolveAudioExtension = (contentType) =>
        contentType && contentType.includes("mpeg") ? "mp3" : "wav";
      const resolveStreamingMimeType = (contentType) =>
        contentType && contentType.includes("audio/wav")
          ? 'audio/wav; codecs="1"'
          : contentType;
      const parseWavHeader = (header) => {
        const readString = (offset, length) =>
          String.fromCharCode(...header.slice(offset, offset + length));
        if (readString(0, 4) !== "RIFF" || readString(8, 4) !== "WAVE") {
          throw new Error("Invalid WAV header.");
        }
        let offset = 12;
        let fmt = null;
        let dataOffset = null;
        while (offset + 8 <= header.length) {
          const chunkId = readString(offset, 4);
          const chunkSize =
            header[offset + 4] |
            (header[offset + 5] << 8) |
            (header[offset + 6] << 16) |
            (header[offset + 7] << 24);
          const chunkStart = offset + 8;
          if (chunkId === "fmt ") {
            const audioFormat = header[chunkStart] | (header[chunkStart + 1] << 8);
            const channels = header[chunkStart + 2] | (header[chunkStart + 3] << 8);
            const sampleRate =
              header[chunkStart + 4] |
              (header[chunkStart + 5] << 8) |
              (header[chunkStart + 6] << 16) |
              (header[chunkStart + 7] << 24);
            const bitsPerSample =
              header[chunkStart + 14] | (header[chunkStart + 15] << 8);
            fmt = { audioFormat, channels, sampleRate, bitsPerSample };
          } else if (chunkId === "data") {
            dataOffset = chunkStart;
            break;
          }
          offset = chunkStart + chunkSize + (chunkSize % 2);
        }
        if (!fmt || dataOffset === null) {
          throw new Error("Unsupported WAV header.");
        }
        if (fmt.audioFormat !== 1) {
          throw new Error("Only PCM WAV is supported for streaming.");
        }
        return { ...fmt, dataOffset };
      };
      const streamWavViaWebAudio = async ({ reader, onStreamStart, onChunk }) => {
        const bufferSize = 4096;
        let audioContext = null;
        let activeProcessor = null;
        let streamDestination = null;
        const sampleQueue = [];
        let sampleOffset = 0;
        let wavInfo = null;
        let pendingPcmBytes = new Uint8Array(0);
        let headerBytes = new Uint8Array(0);
        let playbackStarted = false;
        let streamingEnabled = true;

        const readSample = () => {
          while (sampleQueue.length > 0 && sampleOffset >= sampleQueue[0].length) {
            sampleQueue.shift();
            sampleOffset = 0;
          }
          if (sampleQueue.length === 0) {
            return null;
          }
          const value = sampleQueue[0][sampleOffset];
          sampleOffset += 1;
          return value;
        };

        const handleAudioProcess = (event) => {
          if (!wavInfo) {
            return;
          }
          const channelCount = wavInfo.channels;
          const outputs = Array.from({ length: channelCount }, (_, idx) =>
            event.outputBuffer.getChannelData(idx),
          );
          for (let i = 0; i < outputs[0].length; i += 1) {
            for (let channel = 0; channel < channelCount; channel += 1) {
              const sample = readSample();
              outputs[channel][i] = sample === null ? 0 : sample;
            }
          }
        };

        const enqueuePcm = (pcmBytes) => {
          if (!wavInfo || wavInfo.bitsPerSample !== 16) {
            return;
          }
          const frameSize = wavInfo.channels * (wavInfo.bitsPerSample / 8);
          const combined = new Uint8Array(pendingPcmBytes.length + pcmBytes.length);
          combined.set(pendingPcmBytes);
          combined.set(pcmBytes, pendingPcmBytes.length);
          const remainder = combined.length % frameSize;
          const alignedLength = combined.length - remainder;
          pendingPcmBytes = remainder > 0 ? combined.slice(alignedLength) : new Uint8Array(0);
          if (alignedLength === 0) {
            return;
          }
          const alignedBytes = combined.slice(0, alignedLength);
          const samples = new Float32Array(alignedBytes.length / 2);
          for (let i = 0; i < alignedBytes.length; i += 2) {
            const int16 = alignedBytes[i] | (alignedBytes[i + 1] << 8);
            const signed = int16 >= 0x8000 ? int16 - 0x10000 : int16;
            samples[i / 2] = signed / 32768;
          }
          sampleQueue.push(samples);
        };

        const waitForDrain = async () =>
          new Promise((resolve) => {
            const checkQueue = () => {
              if (!streamingEnabled || sampleQueue.length === 0) {
                resolve();
                return;
              }
              setTimeout(checkQueue, 100);
            };
            checkQueue();
          });

        while (true) {
          const { value, done } = await reader.read();
          if (done) {
            break;
          }
          if (!value) {
            continue;
          }
          onChunk?.(value);

          if (!wavInfo && streamingEnabled) {
            const combined = new Uint8Array(headerBytes.length + value.length);
            combined.set(headerBytes);
            combined.set(value, headerBytes.length);
            headerBytes = combined;
            if (headerBytes.length >= 44) {
              try {
                wavInfo = parseWavHeader(headerBytes);
                if (wavInfo.bitsPerSample !== 16) {
                  throw new Error("Only 16-bit PCM WAV streaming is supported.");
                }
                audioContext = new AudioContext({ sampleRate: wavInfo.sampleRate });
                await audioContext.resume();
                streamDestination = audioContext.createMediaStreamDestination();
                activeProcessor = audioContext.createScriptProcessor(
                  bufferSize,
                  0,
                  wavInfo.channels,
                );
                activeProcessor.onaudioprocess = handleAudioProcess;
                activeProcessor.connect(streamDestination);
                if (!playbackStarted) {
                  playbackStarted = true;
                  onStreamStart?.(streamDestination.stream);
                }
                const pcmStart = headerBytes.slice(wavInfo.dataOffset);
                enqueuePcm(pcmStart);
                headerBytes = new Uint8Array(0);
              } catch (error) {
                streamingEnabled = false;
              }
            }
            continue;
          }

          if (streamingEnabled && !playbackStarted && streamDestination) {
            playbackStarted = true;
            onStreamStart?.(streamDestination.stream);
          }
          if (streamingEnabled) {
            enqueuePcm(value);
          }
        }

        if (streamingEnabled) {
          await waitForDrain();
        }
        if (activeProcessor) {
          activeProcessor.disconnect();
        }
        if (audioContext) {
          audioContext.close().catch(() => {});
        }
      };
      const buildScriptDownloadFilename = ({ voice, durationMinutes, focus, now = new Date() }) =>
        buildDownloadFilename({ voice, durationMinutes, focus, now }).replace(/\.[^.]+$/, ".txt");

      const derivePrimarySense = (focus, eyeState) => {
        if (focus === "sight" && eyeState === "closed") {
          return "touch";
        }
        return focus;
      };

      const updateFocusOptions = (eyeState) => {
        const sightOption = form.querySelector("input[name='focus'][value='sight']");
        const touchOption = form.querySelector("input[name='focus'][value='touch']");
        if (!sightOption || !touchOption) {
          return;
        }
        if (eyeState === "closed") {
          sightOption.disabled = true;
          if (sightOption.checked) {
            touchOption.checked = true;
          }
        } else {
          sightOption.disabled = false;
        }
      };

      const updateDerivedFields = () => {
        const practiceType = getSelectedValue("practiceType");
        const durationMinutes = Number(getSelectedValue("durationMinutes"));
        if (!practiceType || Number.isNaN(durationMinutes)) {
          return;
        }
        const { eyeState } = derivePracticeConfig(practiceType, durationMinutes);
        updateFocusOptions(eyeState);
      };

      const getFormValues = () => {
        const formData = new FormData(form);
        return Object.fromEntries(formData.entries());
      };

      const setFormValues = (values) => {
        Object.entries(values).forEach(([name, value]) => {
          const field = form.elements.namedItem(name);
          if (field && "value" in field && value != null) {
            field.value = value;
          }
        });
      };

      const defaultValues = getFormValues();

      const storedValuesRaw = localStorage.getItem(storageKey);
      if (storedValuesRaw) {
        try {
          const storedValues = JSON.parse(storedValuesRaw);
          if (storedValues && typeof storedValues === "object") {
            setFormValues(storedValues);
          }
        } catch (err) {
          localStorage.removeItem(storageKey);
        }
      }

      updateDerivedFields();
      durationInputs.forEach((input) => {
        input.addEventListener("change", updateDerivedFields);
      });
      practiceTypeInputs.forEach((input) => {
        input.addEventListener("change", updateDerivedFields);
      });

      const loadVersion = async () => {
        if (!appVersion) {
          return;
        }
        try {
          const response = await fetch("/version");
          if (!response.ok) {
            throw new Error("Version unavailable.");
          }
          const data = await response.json();
          appVersion.textContent = `Version: ${data?.version || "unknown"}`;
        } catch (err) {
          appVersion.textContent = "Version: unavailable";
        }
      };

      loadVersion();
      resetButton.addEventListener("click", () => {
        setFormValues(defaultValues);
        localStorage.removeItem(storageKey);
      });

      form.addEventListener("submit", async (event) => {
        event.preventDefault();
        error.hidden = true;
        error.textContent = "";
        status.textContent = "";
        statusPanel.hidden = true;
        spinner.hidden = true;
        result.hidden = true;
        scriptOutput.textContent = "";
        debugOutput.textContent = "";
        debugSection.hidden = true;
        scriptDownloadLink.hidden = true;

        if (currentUrl) {
          URL.revokeObjectURL(currentUrl);
          currentUrl = null;
        }
        if (downloadUrl) {
          URL.revokeObjectURL(downloadUrl);
          downloadUrl = null;
        }
        if (scriptDownloadUrl) {
          URL.revokeObjectURL(scriptDownloadUrl);
          scriptDownloadUrl = null;
        }

        const formData = new FormData(form);
        localStorage.setItem(storageKey, JSON.stringify(Object.fromEntries(formData.entries())));
        const debugEnabled = isDevMode && debugInput?.checked;
        const streamAudioEnabled = streamAudioInput?.checked ?? false;
        const effectiveOutputMode = streamAudioEnabled ? "audio" : "text-audio";
        const language = formData.get("language");
        const voiceGender = formData.get("voiceGender");
        const voiceStyle =
          voiceGender === "male"
            ? maleVoiceByLanguage[language] || "ash"
            : femaleVoiceByLanguage[language] || "alloy";
        const practiceType = formData.get("practiceType");
        const durationMinutes = Number(formData.get("durationMinutes"));
        const focus = formData.get("focus");
        const practiceConfig = derivePracticeConfig(practiceType, durationMinutes);
        const durationConfig = deriveDurationConfig(durationMinutes);
        const primarySense = derivePrimarySense(focus, practiceConfig.eyeState);
        const senseRotation = deriveSenseRotation(practiceType, durationMinutes);
        const basePayload = {
          practiceMode: practiceConfig.practiceMode,
          bodyState: practiceConfig.bodyState,
          eyeState: practiceConfig.eyeState,
          primarySense,
          durationMinutes,
          labelingMode: practiceConfig.labelingMode,
          silenceProfile: durationConfig.silenceProfile,
          normalizationFrequency: durationConfig.normalizationFrequency,
          closingStyle: durationConfig.closingStyle,
          senseRotation,
          languages: [language],
          voiceStyle,
          ttsNewlinePauseSeconds: Number(formData.get("ttsNewlinePauseSeconds")) || 0,
          ...(debugEnabled ? { debugTtsPrompt: true } : {}),
        };

        const buildTtsPayload = (script) => ({
          script,
          language,
          voice: voiceStyle,
          ttsNewlinePauseSeconds: Number(formData.get("ttsNewlinePauseSeconds")) || 0,
        });
        submitButton.disabled = true;
        statusPanel.hidden = false;
        spinner.hidden = false;
        status.textContent = "Generating audio. This can take a few seconds.";

        const requestJson = async (outputMode) => {
          const response = await fetch("/api/generate", {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
              Accept: "application/json",
            },
            body: JSON.stringify({ ...basePayload, outputMode }),
          });

          if (!response.ok) {
            const errorBody = await response.json();
            throw new Error(errorBody?.error?.message || "The generator failed to respond.");
          }

          return response.json();
        };

        const requestStreamed = async () => {
          const response = await fetch("/api/generate", {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
              Accept: "text/event-stream",
            },
            body: JSON.stringify({ ...basePayload, outputMode: effectiveOutputMode }),
          });

          if (!response.ok) {
            const errorContentType = response.headers.get("content-type") || "";
            if (errorContentType.includes("application/json")) {
              const errorBody = await response.json();
              throw new Error(errorBody?.error?.message || "The generator failed to respond.");
            }
            throw new Error(`The generator failed to respond. (${response.status})`);
          }

          if (!response.body) {
            throw new Error("Streaming updates are not available.");
          }

          const reader = response.body.getReader();
          const decoder = new TextDecoder();
          let buffer = "";
          let finalPayload = null;

          while (true) {
            const { value, done } = await reader.read();
            if (done) {
              break;
            }

            buffer += decoder.decode(value, { stream: true });
            let delimiterIndex = buffer.indexOf("\n\n");
            while (delimiterIndex !== -1) {
              const rawEvent = buffer.slice(0, delimiterIndex).trim();
              buffer = buffer.slice(delimiterIndex + 2);
              delimiterIndex = buffer.indexOf("\n\n");

              if (!rawEvent) {
                continue;
              }

              let eventType = "message";
              let data = "";
              for (const line of rawEvent.split("\n")) {
                if (line.startsWith("event:")) {
                  eventType = line.slice(6).trim();
                } else if (line.startsWith("data:")) {
                  data += line.slice(5).trim();
                }
              }

              if (eventType === "status") {
                status.textContent = data;
              } else if (eventType === "done") {
                finalPayload = JSON.parse(data);
              } else if (eventType === "error") {
                throw new Error(data || "Streaming failed.");
              }
            }
          }

          if (!finalPayload) {
            throw new Error("The stream ended before returning a response.");
          }

          return finalPayload;
        };

        const requestAudio = async (script, onStreamStart) => {
          const response = await fetch("/api/tts", {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
              Accept: "audio/wav",
              "x-tts-streaming": "1",
            },
            body: JSON.stringify(buildTtsPayload(script)),
          });

          if (!response.ok) {
            const errorContentType = response.headers.get("content-type") || "";
            if (errorContentType.includes("application/json")) {
              const errorBody = await response.json();
              throw new Error(errorBody?.error?.message || "The generator failed to respond.");
            }
            throw new Error(`The generator failed to respond. (${response.status})`);
          }

          const contentType = response.headers.get("content-type") || "audio/wav";
          if (!response.body) {
            const audioBuffer = await response.arrayBuffer();
            return { blob: new Blob([audioBuffer], { type: contentType }), contentType };
          }

          const reader = response.body.getReader();
          const chunks = [];
          const streamingMimeType = resolveStreamingMimeType(contentType);
          const canStream = typeof MediaSource !== "undefined";
          const canWebAudioStream =
            contentType.includes("audio/wav") && typeof AudioContext !== "undefined";

          if (canWebAudioStream) {
            await streamWavViaWebAudio({
              reader,
              onStreamStart: (mediaStream) =>
                onStreamStart?.({ mediaStream, contentType }),
              onChunk: (chunk) => chunks.push(chunk),
            });
            return { blob: new Blob(chunks, { type: contentType }), contentType };
          }

          if (canStream) {
            const mediaSource = new MediaSource();
            const mediaUrl = URL.createObjectURL(mediaSource);
            let streamStartNotified = false;
            const notifyStreamStart = () => {
              if (streamStartNotified) {
                return;
              }
              streamStartNotified = true;
              if (typeof onStreamStart === "function") {
                onStreamStart({ mediaUrl, contentType });
              }
            };

            try {
              notifyStreamStart();
              await new Promise((resolve, reject) => {
                const handleError = () => reject(new Error("Audio stream failed."));

                mediaSource.addEventListener("error", handleError, { once: true });
                mediaSource.addEventListener(
                  "sourceopen",
                  async () => {
                    try {
                      const sourceBuffer = mediaSource.addSourceBuffer(streamingMimeType);
                      const appendChunk = (chunk) =>
                        new Promise((appendResolve, appendReject) => {
                          const onError = () =>
                            appendReject(new Error("Failed to append audio chunk."));
                          const onUpdateEnd = () => appendResolve();
                          sourceBuffer.addEventListener("error", onError, { once: true });
                          sourceBuffer.addEventListener("updateend", onUpdateEnd, { once: true });
                          sourceBuffer.appendBuffer(chunk);
                        });

                      const firstRead = await reader.read();
                      if (firstRead.done || !firstRead.value) {
                        throw new Error("Audio stream ended before data arrived.");
                      }
                      chunks.push(firstRead.value);
                      await appendChunk(firstRead.value);
                      notifyStreamStart();

                      while (true) {
                        const { value, done } = await reader.read();
                        if (done) {
                          break;
                        }
                        if (value) {
                          chunks.push(value);
                          await appendChunk(value);
                        }
                      }

                      if (mediaSource.readyState === "open") {
                        mediaSource.endOfStream();
                      }
                      resolve();
                    } catch (streamError) {
                      reject(streamError);
                    }
                  },
                  { once: true },
                );
              });

              return { blob: new Blob(chunks, { type: contentType }), mediaUrl, contentType };
            } catch (streamError) {
              console.warn("Falling back to buffered WAV playback.", streamError);
            }
          }

          while (true) {
            const { value, done } = await reader.read();
            if (done) {
              break;
            }
            if (value) {
              chunks.push(value);
            }
          }
          return { blob: new Blob(chunks, { type: contentType }), contentType };
        };

        try {
          let script = "";
          let audioBlob = null;
          let ttsPrompt = null;
          let streamUrl = null;

        if (streamAudioEnabled) {
          const jsonResponse = await requestJson("text");
          script = jsonResponse?.script || "";
          ttsPrompt = jsonResponse?.ttsPrompt || null;
          const cleanedScript = script
            ? script.replace(/\[pause:\d+(?:\.\d+)?\]/g, "").trim()
            : "";
          if (cleanedScript) {
            scriptOutput.textContent = cleanedScript;
            scriptOutput.hidden = false;
            if (scriptDownloadUrl) {
              URL.revokeObjectURL(scriptDownloadUrl);
            }
            scriptDownloadUrl = URL.createObjectURL(
              new Blob([cleanedScript], { type: "text/plain" }),
            );
            scriptDownloadLink.href = scriptDownloadUrl;
            scriptDownloadLink.download = buildScriptDownloadFilename({
              voice: voiceStyle,
              durationMinutes,
              focus: primarySense,
            });
            scriptDownloadLink.hidden = false;
          }
          result.hidden = false;
            const streamResponse = await requestAudio(script, ({ mediaUrl, mediaStream, contentType: streamContentType }) => {
              streamUrl = mediaUrl;
              if (mediaStream) {
                audioPlayer.srcObject = mediaStream;
                audioPlayer.play().catch(() => {});
                audioPlayer.hidden = false;
              } else if (mediaUrl) {
                audioPlayer.srcObject = null;
                audioPlayer.src = mediaUrl;
                audioPlayer.play().catch(() => {});
                audioPlayer.hidden = false;
              }
              status.textContent = "";
            statusPanel.hidden = true;
            spinner.hidden = true;
              const downloadFilename = buildDownloadFilename({
                voice: voiceStyle,
                durationMinutes,
                focus: primarySense,
                extension: resolveAudioExtension(streamContentType),
              });
              downloadLink.download = downloadFilename;
              downloadLink.hidden = true;
              result.hidden = false;
            });
            audioBlob = streamResponse?.blob || null;
            if (streamResponse?.mediaUrl) {
              streamUrl = streamResponse.mediaUrl;
            } else if (streamUrl) {
              URL.revokeObjectURL(streamUrl);
              streamUrl = null;
            }
            const extension = resolveAudioExtension(streamResponse?.contentType);
            downloadLink.download = buildDownloadFilename({
              voice: voiceStyle,
              durationMinutes,
              focus: primarySense,
              extension,
            });
            script = jsonResponse?.script || "";
            ttsPrompt = jsonResponse?.ttsPrompt || null;
          } else {
            const jsonResponse = await requestJson(effectiveOutputMode);
            script = jsonResponse?.script || "";
            ttsPrompt = jsonResponse?.ttsPrompt || null;
            if (effectiveOutputMode === "text-audio" && jsonResponse?.audioBase64) {
              const binary = atob(jsonResponse.audioBase64);
              const bytes = new Uint8Array(binary.length);
              for (let index = 0; index < binary.length; index += 1) {
                bytes[index] = binary.charCodeAt(index);
              }
              audioBlob = new Blob([bytes], {
                type: jsonResponse?.audioContentType || "audio/wav",
              });
            }
          }

          if (audioBlob) {
            if (currentUrl) {
              URL.revokeObjectURL(currentUrl);
            }
            if (downloadUrl) {
              URL.revokeObjectURL(downloadUrl);
            }
            downloadUrl = URL.createObjectURL(audioBlob);
            currentUrl = streamUrl || downloadUrl;
            if (audioPlayer.src !== currentUrl) {
              audioPlayer.srcObject = null;
              audioPlayer.src = currentUrl;
            }
            audioPlayer.hidden = false;
            downloadLink.href = downloadUrl;
            downloadLink.download = buildDownloadFilename({
              voice: voiceStyle,
              durationMinutes,
              focus: primarySense,
              extension: resolveAudioExtension(audioBlob.type),
            });
            downloadLink.hidden = false;
          } else {
            audioPlayer.hidden = true;
            downloadLink.hidden = true;
          }

          const cleanedScript = script ? script.replace(/\[pause:\d+(?:\.\d+)?\]/g, "").trim() : "";

          if (cleanedScript) {
            scriptOutput.textContent = cleanedScript;
            scriptOutput.hidden = false;
            if (scriptDownloadUrl) {
              URL.revokeObjectURL(scriptDownloadUrl);
            }
            scriptDownloadUrl = URL.createObjectURL(new Blob([cleanedScript], { type: "text/plain" }));
            scriptDownloadLink.href = scriptDownloadUrl;
            scriptDownloadLink.download = buildScriptDownloadFilename({
              voice: voiceStyle,
              durationMinutes,
              focus: primarySense,
            });
            scriptDownloadLink.hidden = false;
          } else {
            scriptOutput.hidden = true;
            scriptDownloadLink.hidden = true;
          }

          if (ttsPrompt) {
            debugOutput.textContent = JSON.stringify(ttsPrompt, null, 2);
            debugSection.hidden = false;
          } else {
            debugSection.hidden = true;
          }

          result.hidden = false;
          status.textContent = "";
          statusPanel.hidden = true;
          spinner.hidden = true;
        } catch (err) {
          error.hidden = false;
          error.textContent = err instanceof Error ? err.message : "Something went wrong.";
          status.textContent = "";
          spinner.hidden = true;
        } finally {
          submitButton.disabled = false;
        }
      });
    </script>
  </body>
</html>
