<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>PQ Reps Audio Generator</title>
    <style>
      body {
        font-family: "Inter", system-ui, sans-serif;
        background: #f5f5f5;
        margin: 0;
        padding: 2rem;
        color: #1f1f1f;
      }
      main {
        max-width: 720px;
        margin: 0 auto;
        background: #fff;
        padding: 2rem;
        border-radius: 16px;
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.08);
      }
      h1 {
        margin-top: 0;
      }
      .version {
        margin-top: -0.25rem;
        color: #666;
        font-size: 0.9rem;
      }
      form {
        display: grid;
        gap: 1.5rem;
      }
      label {
        display: grid;
        gap: 0.5rem;
        font-weight: 600;
      }
      input,
      select {
        padding: 0.75rem;
        border-radius: 8px;
        border: 1px solid #ccc;
        font-size: 1rem;
      }
      button {
        padding: 0.85rem 1.5rem;
        background: #111;
        color: #fff;
        border: none;
        border-radius: 999px;
        font-weight: 600;
        cursor: pointer;
      }
      .button-secondary {
        background: #e5e5e5;
        color: #111;
      }
      button[disabled] {
        cursor: not-allowed;
        background: #888;
      }
      .status-panel {
        margin-top: 1.5rem;
        padding: 1rem;
        border-radius: 12px;
        background: #f0f4ff;
        border: 1px solid #d5ddf7;
        display: grid;
        gap: 0.5rem;
      }
      .status-panel[hidden] {
        display: none;
      }
      .status-row {
        display: flex;
        align-items: center;
        gap: 0.75rem;
      }
      .spinner {
        width: 18px;
        height: 18px;
        border-radius: 50%;
        border: 3px solid #c3c9f7;
        border-top-color: #3545a3;
        animation: spin 0.9s linear infinite;
      }
      .spinner[hidden] {
        display: none;
      }
      .status {
        margin: 0;
        color: #2a2f4a;
        font-weight: 600;
      }
      .progress-list {
        margin: 0.5rem 0 0;
        padding-left: 1.25rem;
        color: #444;
      }
      .progress-list li {
        margin: 0.25rem 0;
      }
      .error {
        background: #ffecec;
        color: #b30000;
        padding: 1rem;
        border-radius: 8px;
      }
      .result {
        margin-top: 2rem;
        background: #f7f7f7;
        padding: 1.5rem;
        border-radius: 12px;
      }
      .debug-prompt {
        margin-top: 1.5rem;
        background: #111;
        color: #f5f5f5;
        padding: 1rem;
        border-radius: 8px;
        white-space: pre-wrap;
        word-break: break-word;
      }
      .hint {
        font-weight: 400;
        color: #555;
        font-size: 0.9rem;
      }
      .download-link {
        display: inline-flex;
        margin-top: 0.75rem;
        font-weight: 600;
        color: #0f2d81;
        text-decoration: none;
      }
      .option-hint {
        font-weight: 400;
        color: #555;
        font-size: 0.9rem;
      }
      .footer {
        margin-top: 2.5rem;
        padding-top: 1.25rem;
        border-top: 1px solid #e5e5e5;
        color: #666;
        font-size: 0.9rem;
        line-height: 1.5;
      }
      @keyframes spin {
        to {
          transform: rotate(360deg);
        }
      }
    </style>
  </head>
  <body>
    <main>
      <h1>PQ Reps Audio Generator</h1>
      <p id="app-version" class="version">Version: loading...</p>
      <p>Choose the type of PQ Reps you'd like to practice.</p>
      <p>Audio is AI-generated.</p>

      <form id="generator-form">
        <label>
          Practice type
          <select name="practiceType" required>
            <option value="still_eyes_closed">Still (Eyes closed)</option>
            <option value="still_eyes_open">Still (Eyes open)</option>
            <option value="moving">Moving</option>
            <option value="labeling">Labeling</option>
          </select>
        </label>

        <label>
          Focus
          <select name="focus" required>
            <option value="touch">Touch</option>
            <option value="hearing">Hearing</option>
            <option value="sight">Sight</option>
            <option value="breath">Breath</option>
          </select>
        </label>

        <label>
          Duration
          <select name="durationMinutes" required>
            <option value="1">1 minute</option>
            <option value="2">2 minutes</option>
            <option value="5">5 minutes</option>
            <option value="12">12 minutes</option>
          </select>
        </label>

        <label>
          Language
          <select name="language" required>
            <option value="en">English</option>
            <option value="es">Spanish</option>
            <option value="fr">French</option>
            <option value="de">German</option>
          </select>
        </label>

        <label>
          Voice
          <select name="voiceGender" required>
            <option value="male">Male</option>
            <option value="female" selected>Female</option>
          </select>
          <span class="option-hint">Choose the voice you prefer for guidance.</span>
        </label>

        <label>
          Audio delivery
          <div style="display: flex; align-items: center; gap: 0.5rem;">
            <input type="checkbox" name="streamAudio" id="stream-audio" />
            <label for="stream-audio" class="option-hint" style="margin: 0;">
              Stream audio as it is generated
            </label>
          </div>
          <span class="option-hint">
            Streaming starts playback sooner but skips the script output.
          </span>
        </label>

        <div id="dev-controls" hidden>
          <label>
            TTS newline pause (seconds)
            <input type="number" name="ttsNewlinePauseSeconds" min="0" step="0.5" value="1" />
          </label>

          <label>
            <span>Debug TTS prompt</span>
            <span class="hint">Include the raw TTS payload for OpenAI playground testing.</span>
            <input type="checkbox" name="debugTtsPrompt" />
          </label>
        </div>

        <div style="display: flex; gap: 0.75rem; flex-wrap: wrap;">
          <button type="submit" id="submit-button">Generate</button>
          <button type="button" id="reset-button" class="button-secondary">
            Reset to defaults
          </button>
        </div>
      </form>

      <section id="status-panel" class="status-panel" hidden>
        <div class="status-row">
          <span id="spinner" class="spinner" aria-hidden="true"></span>
          <p class="status" id="status" aria-live="polite"></p>
        </div>
      </section>
      <div id="error" class="error" hidden></div>

      <section id="result" class="result" hidden>
        <h2>Your session is ready</h2>
        <audio id="audio-player" controls style="width: 100%;" hidden></audio>
        <a id="download-link" class="download-link" download="pq-reps.wav" hidden>
          Download the WAV
        </a>
        <a id="script-download-link" class="download-link" download="pq-reps.txt" hidden>
          Download the script
        </a>
        <p id="script-output" style="margin-top: 1rem; white-space: pre-line;" hidden></p>
        <div id="debug-section" hidden>
          <h3>TTS prompt (debug)</h3>
          <pre id="debug-output" class="debug-prompt"></pre>
        </div>
      </section>

      <footer class="footer">
        Inspired by publicly available teachings on Positive Intelligence® and PQ Reps® by Shirzad
        Chamine. Not affiliated with or endorsed by Positive Intelligence LLC. For educational
        purposes only.
      </footer>
    </main>

    <script>
      const form = document.getElementById("generator-form");
      const practiceTypeInput = form.querySelector("select[name='practiceType']");
      const focusInput = form.querySelector("select[name='focus']");
      const durationInput = form.querySelector("select[name='durationMinutes']");
      const status = document.getElementById("status");
      const statusPanel = document.getElementById("status-panel");
      const spinner = document.getElementById("spinner");
      const error = document.getElementById("error");
      const result = document.getElementById("result");
      const audioPlayer = document.getElementById("audio-player");
      const downloadLink = document.getElementById("download-link");
      const scriptDownloadLink = document.getElementById("script-download-link");
      const scriptOutput = document.getElementById("script-output");
      const submitButton = document.getElementById("submit-button");
      const debugInput = form.querySelector("input[name='debugTtsPrompt']");
      const streamAudioInput = form.querySelector("input[name='streamAudio']");
      const appVersion = document.getElementById("app-version");
      const resetButton = document.getElementById("reset-button");
      const debugSection = document.getElementById("debug-section");
      const debugOutput = document.getElementById("debug-output");
      const devControls = document.getElementById("dev-controls");
      let currentUrl = null;
      let downloadUrl = null;
      let scriptDownloadUrl = null;
      const storageKey = "pq-reps-form";
      const femaleVoiceByLanguage = { es: "nova", fr: "nova" };
      const maleVoiceByLanguage = { es: "onyx", fr: "onyx" };
      const isDevMode = new URLSearchParams(window.location.search).get("dev") === "1";

      if (devControls) {
        devControls.hidden = !isDevMode;
      }

      const derivePracticeConfig = (practiceType, durationMinutes) => {
        if (practiceType === "still_eyes_closed") {
          return {
            practiceMode: "tactile",
            bodyState: "still_seated_closed_eyes",
            eyeState: "closed",
            labelingMode: "none",
          };
        }
        if (practiceType === "still_eyes_open") {
          return {
            practiceMode: "sitting",
            bodyState: "still_seated",
            eyeState: "open_diffused",
            labelingMode: "none",
          };
        }
        if (practiceType === "moving") {
          return {
            practiceMode: "moving",
            bodyState: "moving",
            eyeState: "open_focused",
            labelingMode: "none",
          };
        }
        const labelingMode = durationMinutes < 5 ? "breath_anchor" : "scan_and_label";
        return {
          practiceMode: durationMinutes < 5 ? "label_with_anchor" : "label_while_scanning",
          bodyState: "still_seated_closed_eyes",
          eyeState: "closed",
          labelingMode,
        };
      };

      const deriveDurationConfig = (durationMinutes) => {
        if (durationMinutes === 1 || durationMinutes === 2) {
          return {
            silenceProfile: "none",
            normalizationFrequency: "once",
            closingStyle: "minimal",
          };
        }
        if (durationMinutes === 5) {
          return {
            silenceProfile: "short_pauses",
            normalizationFrequency: "periodic",
            closingStyle: "pq_framed",
          };
        }
        return {
          silenceProfile: "extended_silence",
          normalizationFrequency: "repeated",
          closingStyle: "pq_framed_with_progression",
        };
      };

      const deriveSenseRotation = (practiceType, durationMinutes) => {
        if (durationMinutes >= 5 && practiceType !== "labeling") {
          return "guided_rotation";
        }
        return "none";
      };

      const formatTimestamp = (date) => {
        const year = date.getFullYear();
        const month = String(date.getMonth() + 1).padStart(2, "0");
        const day = String(date.getDate()).padStart(2, "0");
        const hour = String(date.getHours()).padStart(2, "0");
        const minute = String(date.getMinutes()).padStart(2, "0");
        return `${year}${month}${day}-${hour}${minute}`;
      };

      const buildDownloadFilename = ({ voice, durationMinutes, focus, now = new Date() }) =>
        `pq-reps_${voice}_${durationMinutes}_${focus}_${formatTimestamp(now)}.wav`;
      const buildScriptDownloadFilename = ({ voice, durationMinutes, focus, now = new Date() }) =>
        buildDownloadFilename({ voice, durationMinutes, focus, now }).replace(/\.wav$/, ".txt");

      const derivePrimarySense = (focus, eyeState) => {
        if (focus === "sight" && eyeState === "closed") {
          return "touch";
        }
        return focus;
      };

      const updateFocusOptions = (eyeState) => {
        const sightOption = focusInput.querySelector("option[value='sight']");
        if (!sightOption) {
          return;
        }
        if (eyeState === "closed") {
          sightOption.hidden = true;
          if (focusInput.value === "sight") {
            focusInput.value = "touch";
          }
        } else {
          sightOption.hidden = false;
        }
      };

      const updateDerivedFields = () => {
        const practiceType = practiceTypeInput.value;
        const durationMinutes = Number(durationInput.value);
        const { eyeState } = derivePracticeConfig(practiceType, durationMinutes);
        updateFocusOptions(eyeState);
      };

      const getFormValues = () => {
        const formData = new FormData(form);
        return Object.fromEntries(formData.entries());
      };

      const setFormValues = (values) => {
        Object.entries(values).forEach(([name, value]) => {
          const field = form.elements.namedItem(name);
          if (field && "value" in field && value != null) {
            field.value = value;
          }
        });
      };

      const defaultValues = getFormValues();

      const storedValuesRaw = localStorage.getItem(storageKey);
      if (storedValuesRaw) {
        try {
          const storedValues = JSON.parse(storedValuesRaw);
          if (storedValues && typeof storedValues === "object") {
            setFormValues(storedValues);
          }
        } catch (err) {
          localStorage.removeItem(storageKey);
        }
      }

      updateDerivedFields();
      durationInput.addEventListener("change", updateDerivedFields);
      practiceTypeInput.addEventListener("change", updateDerivedFields);

      const loadVersion = async () => {
        if (!appVersion) {
          return;
        }
        try {
          const response = await fetch("/version");
          if (!response.ok) {
            throw new Error("Version unavailable.");
          }
          const data = await response.json();
          appVersion.textContent = `Version: ${data?.version || "unknown"}`;
        } catch (err) {
          appVersion.textContent = "Version: unavailable";
        }
      };

      loadVersion();
      resetButton.addEventListener("click", () => {
        setFormValues(defaultValues);
        localStorage.removeItem(storageKey);
      });

      form.addEventListener("submit", async (event) => {
        event.preventDefault();
        error.hidden = true;
        error.textContent = "";
        status.textContent = "";
        statusPanel.hidden = true;
        spinner.hidden = true;
        result.hidden = true;
        scriptOutput.textContent = "";
        debugOutput.textContent = "";
        debugSection.hidden = true;
        scriptDownloadLink.hidden = true;

        if (currentUrl) {
          URL.revokeObjectURL(currentUrl);
          currentUrl = null;
        }
        if (downloadUrl) {
          URL.revokeObjectURL(downloadUrl);
          downloadUrl = null;
        }
        if (scriptDownloadUrl) {
          URL.revokeObjectURL(scriptDownloadUrl);
          scriptDownloadUrl = null;
        }

        const formData = new FormData(form);
        localStorage.setItem(storageKey, JSON.stringify(Object.fromEntries(formData.entries())));
        const debugEnabled = isDevMode && debugInput?.checked;
        const streamAudioEnabled = streamAudioInput?.checked ?? false;
        const effectiveOutputMode = streamAudioEnabled ? "audio" : "text-audio";
        const language = formData.get("language");
        const voiceGender = formData.get("voiceGender");
        const voiceStyle =
          voiceGender === "male"
            ? maleVoiceByLanguage[language] || "ash"
            : femaleVoiceByLanguage[language] || "alloy";
        const practiceType = formData.get("practiceType");
        const durationMinutes = Number(formData.get("durationMinutes"));
        const focus = formData.get("focus");
        const practiceConfig = derivePracticeConfig(practiceType, durationMinutes);
        const durationConfig = deriveDurationConfig(durationMinutes);
        const primarySense = derivePrimarySense(focus, practiceConfig.eyeState);
        const senseRotation = deriveSenseRotation(practiceType, durationMinutes);
        const payload = {
          practiceMode: practiceConfig.practiceMode,
          bodyState: practiceConfig.bodyState,
          eyeState: practiceConfig.eyeState,
          primarySense,
          durationMinutes,
          labelingMode: practiceConfig.labelingMode,
          silenceProfile: durationConfig.silenceProfile,
          normalizationFrequency: durationConfig.normalizationFrequency,
          closingStyle: durationConfig.closingStyle,
          senseRotation,
          languages: [language],
          voiceStyle,
          ...(isDevMode
            ? { ttsNewlinePauseSeconds: Number(formData.get("ttsNewlinePauseSeconds")) || 0 }
            : {}),
          outputMode: effectiveOutputMode,
          ...(debugEnabled ? { debugTtsPrompt: true } : {}),
        };
        const streamingEnabled = streamAudioEnabled;

        submitButton.disabled = true;
        statusPanel.hidden = false;
        spinner.hidden = false;
        status.textContent = "Generating audio. This can take a few seconds.";

        const requestJson = async () => {
          const response = await fetch("/api/generate", {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
              Accept: "application/json",
            },
            body: JSON.stringify(payload),
          });

          if (!response.ok) {
            const errorBody = await response.json();
            throw new Error(errorBody?.error?.message || "The generator failed to respond.");
          }

          return response.json();
        };

        const requestStreamed = async () => {
          const response = await fetch("/api/generate", {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
              Accept: "text/event-stream",
            },
            body: JSON.stringify(payload),
          });

          if (!response.ok) {
            const errorContentType = response.headers.get("content-type") || "";
            if (errorContentType.includes("application/json")) {
              const errorBody = await response.json();
              throw new Error(errorBody?.error?.message || "The generator failed to respond.");
            }
            throw new Error(`The generator failed to respond. (${response.status})`);
          }

          if (!response.body) {
            throw new Error("Streaming updates are not available.");
          }

          const reader = response.body.getReader();
          const decoder = new TextDecoder();
          let buffer = "";
          let finalPayload = null;

          while (true) {
            const { value, done } = await reader.read();
            if (done) {
              break;
            }

            buffer += decoder.decode(value, { stream: true });
            let delimiterIndex = buffer.indexOf("\n\n");
            while (delimiterIndex !== -1) {
              const rawEvent = buffer.slice(0, delimiterIndex).trim();
              buffer = buffer.slice(delimiterIndex + 2);
              delimiterIndex = buffer.indexOf("\n\n");

              if (!rawEvent) {
                continue;
              }

              let eventType = "message";
              let data = "";
              for (const line of rawEvent.split("\n")) {
                if (line.startsWith("event:")) {
                  eventType = line.slice(6).trim();
                } else if (line.startsWith("data:")) {
                  data += line.slice(5).trim();
                }
              }

              if (eventType === "status") {
                status.textContent = data;
              } else if (eventType === "done") {
                finalPayload = JSON.parse(data);
              } else if (eventType === "error") {
                throw new Error(data || "Streaming failed.");
              }
            }
          }

          if (!finalPayload) {
            throw new Error("The stream ended before returning a response.");
          }

          return finalPayload;
        };

        const requestAudio = async (onStreamStart) => {
          const response = await fetch("/api/generate", {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
              Accept: "audio/wav",
              "x-tts-streaming": "1",
            },
            body: JSON.stringify(payload),
          });

          if (!response.ok) {
            const errorContentType = response.headers.get("content-type") || "";
            if (errorContentType.includes("application/json")) {
              const errorBody = await response.json();
              throw new Error(errorBody?.error?.message || "The generator failed to respond.");
            }
            throw new Error(`The generator failed to respond. (${response.status})`);
          }

          const contentType = response.headers.get("content-type") || "audio/wav";
          if (!response.body) {
            const audioBuffer = await response.arrayBuffer();
            return { blob: new Blob([audioBuffer], { type: contentType }) };
          }

          const mediaSource = new MediaSource();
          const mediaUrl = URL.createObjectURL(mediaSource);
          if (typeof onStreamStart === "function") {
            onStreamStart(mediaUrl);
          }

          const reader = response.body.getReader();
          const chunks = [];

          await new Promise((resolve, reject) => {
            const handleError = () => reject(new Error("Audio stream failed."));

            mediaSource.addEventListener("error", handleError, { once: true });
            mediaSource.addEventListener(
              "sourceopen",
              async () => {
                try {
                  const sourceBuffer = mediaSource.addSourceBuffer(contentType);
                  const appendChunk = (chunk) =>
                    new Promise((appendResolve, appendReject) => {
                      const onError = () => appendReject(new Error("Failed to append audio chunk."));
                      const onUpdateEnd = () => appendResolve();
                      sourceBuffer.addEventListener("error", onError, { once: true });
                      sourceBuffer.addEventListener("updateend", onUpdateEnd, { once: true });
                      sourceBuffer.appendBuffer(chunk);
                    });

                  while (true) {
                    const { value, done } = await reader.read();
                    if (done) {
                      break;
                    }
                    if (value) {
                      chunks.push(value);
                      await appendChunk(value);
                    }
                  }

                  if (mediaSource.readyState === "open") {
                    mediaSource.endOfStream();
                  }
                  resolve();
                } catch (streamError) {
                  reject(streamError);
                }
              },
              { once: true },
            );
          });

          return { blob: new Blob(chunks, { type: contentType }), mediaUrl };
        };

        try {
          let script = "";
          let audioBlob = null;
          let ttsPrompt = null;
          let streamUrl = null;

          if (streamingEnabled) {
            const streamedResponse = await requestStreamed();
            script = streamedResponse?.script || "";
            ttsPrompt = streamedResponse?.ttsPrompt || null;
            if (streamedResponse?.audioBase64) {
              const binary = atob(streamedResponse.audioBase64);
              const bytes = new Uint8Array(binary.length);
              for (let index = 0; index < binary.length; index += 1) {
                bytes[index] = binary.charCodeAt(index);
              }
              audioBlob = new Blob([bytes], {
                type: streamedResponse?.audioContentType || "audio/wav",
              });
            }
          } else if (effectiveOutputMode === "audio") {
            const streamResponse = await requestAudio((mediaUrl) => {
              streamUrl = mediaUrl;
              audioPlayer.src = mediaUrl;
              audioPlayer.hidden = false;
              const downloadFilename = buildDownloadFilename({
                voice: voiceStyle,
                durationMinutes,
                focus: primarySense,
              });
              downloadLink.download = downloadFilename;
              downloadLink.hidden = true;
              result.hidden = false;
            });
            audioBlob = streamResponse?.blob || null;
            if (streamResponse?.mediaUrl) {
              streamUrl = streamResponse.mediaUrl;
            }
          } else {
            const jsonResponse = await requestJson();
            script = jsonResponse?.script || "";
            ttsPrompt = jsonResponse?.ttsPrompt || null;
            if (effectiveOutputMode === "text-audio" && jsonResponse?.audioBase64) {
              const binary = atob(jsonResponse.audioBase64);
              const bytes = new Uint8Array(binary.length);
              for (let index = 0; index < binary.length; index += 1) {
                bytes[index] = binary.charCodeAt(index);
              }
              audioBlob = new Blob([bytes], {
                type: jsonResponse?.audioContentType || "audio/wav",
              });
            }
          }

          if (audioBlob) {
            if (currentUrl) {
              URL.revokeObjectURL(currentUrl);
            }
            if (downloadUrl) {
              URL.revokeObjectURL(downloadUrl);
            }
            downloadUrl = URL.createObjectURL(audioBlob);
            currentUrl = streamUrl || downloadUrl;
            audioPlayer.src = currentUrl;
            audioPlayer.hidden = false;
            downloadLink.href = downloadUrl;
            downloadLink.download = buildDownloadFilename({
              voice: voiceStyle,
              durationMinutes,
              focus: primarySense,
            });
            downloadLink.hidden = false;
          } else {
            audioPlayer.hidden = true;
            downloadLink.hidden = true;
          }

          const shouldShowScript =
            effectiveOutputMode === "text" || effectiveOutputMode === "text-audio";
          const cleanedScript = shouldShowScript
            ? script.replace(/\[pause:\d+(?:\.\d+)?\]/g, "").trim()
            : "";

          if (cleanedScript) {
            scriptOutput.textContent = cleanedScript;
            scriptOutput.hidden = false;
            if (scriptDownloadUrl) {
              URL.revokeObjectURL(scriptDownloadUrl);
            }
            scriptDownloadUrl = URL.createObjectURL(new Blob([cleanedScript], { type: "text/plain" }));
            scriptDownloadLink.href = scriptDownloadUrl;
            scriptDownloadLink.download = buildScriptDownloadFilename({
              voice: voiceStyle,
              durationMinutes,
              focus: primarySense,
            });
            scriptDownloadLink.hidden = false;
          } else {
            scriptOutput.hidden = true;
            scriptDownloadLink.hidden = true;
          }

          if (ttsPrompt) {
            debugOutput.textContent = JSON.stringify(ttsPrompt, null, 2);
            debugSection.hidden = false;
          } else {
            debugSection.hidden = true;
          }

          result.hidden = false;
          status.textContent = "";
          statusPanel.hidden = true;
          spinner.hidden = true;
        } catch (err) {
          error.hidden = false;
          error.textContent = err instanceof Error ? err.message : "Something went wrong.";
          status.textContent = "";
          spinner.hidden = true;
        } finally {
          submitButton.disabled = false;
        }
      });
    </script>
  </body>
</html>
