<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>PQ Reps Audio Generator</title>
    <style>
      body {
        font-family: "Inter", system-ui, sans-serif;
        background: #f5f5f5;
        margin: 0;
        padding: 2rem;
        color: #1f1f1f;
      }
      main {
        max-width: 720px;
        margin: 0 auto;
        background: #fff;
        padding: 2rem;
        border-radius: 16px;
        box-shadow: 0 10px 30px rgba(0, 0, 0, 0.08);
      }
      h1 {
        margin-top: 0;
      }
      .version {
        margin-top: -0.25rem;
        color: #666;
        font-size: 0.9rem;
      }
      form {
        display: grid;
        gap: 1.5rem;
      }
      label {
        display: grid;
        gap: 0.5rem;
        font-weight: 600;
      }
      input,
      select {
        padding: 0.75rem;
        border-radius: 8px;
        border: 1px solid #ccc;
        font-size: 1rem;
      }
      button {
        padding: 0.85rem 1.5rem;
        background: #111;
        color: #fff;
        border: none;
        border-radius: 999px;
        font-weight: 600;
        cursor: pointer;
      }
      .button-secondary {
        background: #e5e5e5;
        color: #111;
      }
      button[disabled] {
        cursor: not-allowed;
        background: #888;
      }
      .status {
        margin-top: 1rem;
        color: #444;
      }
      .progress-list {
        margin: 0.5rem 0 0;
        padding-left: 1.25rem;
        color: #444;
      }
      .progress-list li {
        margin: 0.25rem 0;
      }
      .error {
        background: #ffecec;
        color: #b30000;
        padding: 1rem;
        border-radius: 8px;
      }
      .result {
        margin-top: 2rem;
        background: #f7f7f7;
        padding: 1.5rem;
        border-radius: 12px;
      }
      .download-link {
        display: inline-flex;
        margin-top: 0.75rem;
        font-weight: 600;
        color: #0f2d81;
        text-decoration: none;
      }
    </style>
  </head>
  <body>
    <main>
      <h1>PQ Reps Audio Generator</h1>
      <p>
        Create guided PQ Reps that sharpen the PQ brain with tactile, breath, or visual focus.
        Pick how you are practicing (for example, tactile PQ reps) and set how long the rep
        should run.
      </p>

      <form id="generator-form">
        <label>
          Practice Mode
          <select name="practiceMode" required>
            <option value="tactile">Tactile</option>
            <option value="tense_relax">Tense + Relax</option>
            <option value="moving">Moving</option>
            <option value="sitting">Sitting</option>
            <option value="label_with_anchor">Label with Anchor</option>
            <option value="label_while_scanning">Label While Scanning</option>
          </select>
        </label>

        <label>
          Body State
          <select name="bodyState" required>
            <option value="still_seated">Still seated</option>
            <option value="still_seated_closed_eyes">Still seated, eyes closed</option>
            <option value="moving">Moving</option>
          </select>
        </label>

        <label>
          Eye State
          <select name="eyeState" required>
            <option value="closed">Closed</option>
            <option value="open_focused">Open, focused</option>
            <option value="open_diffused">Open, diffused</option>
          </select>
        </label>

        <label>
          Primary Sense
          <select name="primarySense" required>
            <option value="touch">Touch</option>
            <option value="hearing">Hearing</option>
            <option value="sight">Sight</option>
            <option value="breath">Breath</option>
            <option value="body_weight">Body weight</option>
            <option value="smell">Smell</option>
            <option value="taste">Taste</option>
          </select>
        </label>

        <label>
          Duration: <span id="duration-label">2 minutes</span>
          <select name="durationMinutes" required>
            <option value="2">2 minutes</option>
            <option value="5">5 minutes</option>
            <option value="12">12 minutes</option>
          </select>
        </label>

        <label>
          Labeling Mode
          <select name="labelingMode" required>
            <option value="none">None</option>
            <option value="breath_anchor">Breath anchor</option>
            <option value="scan_and_label">Scan and label</option>
          </select>
        </label>

        <label>
          Silence Profile
          <select name="silenceProfile" required>
            <option value="none">None</option>
            <option value="short_pauses">Short pauses</option>
            <option value="extended_silence">Extended silence</option>
          </select>
        </label>

        <label>
          Normalization Frequency
          <select name="normalizationFrequency" required>
            <option value="once">Once</option>
            <option value="periodic">Periodic</option>
            <option value="repeated">Repeated</option>
          </select>
        </label>

        <label>
          Closing Style
          <select name="closingStyle" required>
            <option value="minimal">Minimal</option>
            <option value="pq_framed">PQ framed</option>
            <option value="pq_framed_with_progression">PQ framed with progression</option>
          </select>
        </label>

        <label>
          Sense Rotation
          <select name="senseRotation">
            <option value="none">None</option>
            <option value="guided_rotation">Guided rotation</option>
            <option value="free_choice">Free choice</option>
          </select>
        </label>

        <label>
          Language
          <select name="language" required>
            <option value="en">English</option>
            <option value="es">Spanish</option>
            <option value="fr">French</option>
            <option value="de">German</option>
          </select>
        </label>

        <label>
          Output
          <select name="outputMode">
            <option value="text">Text only</option>
            <option value="audio" selected>Audio only</option>
            <option value="text-audio">Text + audio</option>
          </select>
        </label>

        <label>
          <input type="checkbox" name="streaming" />
          Stream progress updates
        </label>

        <div style="display: flex; gap: 0.75rem; flex-wrap: wrap;">
          <button type="submit" id="submit-button">Generate audio</button>
          <button type="button" id="reset-button" class="button-secondary">
            Reset to defaults
          </button>
        </div>
      </form>

      <p class="status" id="status"></p>
      <ol id="progress-list" class="progress-list" hidden></ol>
      <div id="error" class="error" hidden></div>

      <section id="result" class="result" hidden>
        <h2>Your session is ready</h2>
        <audio id="audio-player" controls style="width: 100%;" hidden></audio>
        <a id="download-link" class="download-link" download="pq-reps.wav" hidden>
          Download the WAV
        </a>
        <p id="script-output" style="margin-top: 1rem; white-space: pre-line;" hidden></p>
      </section>
    </main>

    <script>
      const form = document.getElementById("generator-form");
      const durationInput = form.querySelector("select[name='durationMinutes']");
      const durationLabel = document.getElementById("duration-label");
      const status = document.getElementById("status");
      const error = document.getElementById("error");
      const result = document.getElementById("result");
      const audioPlayer = document.getElementById("audio-player");
      const downloadLink = document.getElementById("download-link");
      const scriptOutput = document.getElementById("script-output");
      const submitButton = document.getElementById("submit-button");
      const progressList = document.getElementById("progress-list");
      const streamingInput = form.querySelector("input[name='streaming']");
      const appVersion = document.getElementById("app-version");
      const resetButton = document.getElementById("reset-button");
      let currentUrl = null;
      const storageKey = "pq-reps-form";

      const updateDurationLabel = () => {
        durationLabel.textContent = `${durationInput.value} minutes`;
      };

      const resetProgress = () => {
        progressList.innerHTML = "";
        progressList.hidden = true;
      };

      const addProgressStep = (message) => {
        const item = document.createElement("li");
        item.textContent = message;
        progressList.appendChild(item);
        progressList.hidden = false;
      };

      const getFormValues = () => {
        const formData = new FormData(form);
        return Object.fromEntries(formData.entries());
      };

      const setFormValues = (values) => {
        Object.entries(values).forEach(([name, value]) => {
          const field = form.elements.namedItem(name);
          if (field && "value" in field && value != null) {
            field.value = value;
          }
        });
        updateDurationLabel();
      };

      const defaultValues = getFormValues();

      const storedValuesRaw = localStorage.getItem(storageKey);
      if (storedValuesRaw) {
        try {
          const storedValues = JSON.parse(storedValuesRaw);
          if (storedValues && typeof storedValues === "object") {
            setFormValues(storedValues);
          }
        } catch (err) {
          localStorage.removeItem(storageKey);
        }
      }

      updateDurationLabel();
      durationInput.addEventListener("change", updateDurationLabel);

      const loadVersion = async () => {
        try {
          const response = await fetch("/version");
          if (!response.ok) {
            throw new Error("Version unavailable.");
          }
          const data = await response.json();
          appVersion.textContent = `Version: ${data?.version || "unknown"}`;
        } catch (err) {
          appVersion.textContent = "Version: unavailable";
        }
      };

      loadVersion();
      resetButton.addEventListener("click", () => {
        setFormValues(defaultValues);
        localStorage.removeItem(storageKey);
      });

      form.addEventListener("submit", async (event) => {
        event.preventDefault();
        error.hidden = true;
        error.textContent = "";
        status.textContent = "";
        resetProgress();
        result.hidden = true;
        scriptOutput.textContent = "";

        if (currentUrl) {
          URL.revokeObjectURL(currentUrl);
          currentUrl = null;
        }

        const formData = new FormData(form);
        localStorage.setItem(storageKey, JSON.stringify(Object.fromEntries(formData.entries())));
        const payload = {
          practiceMode: formData.get("practiceMode"),
          bodyState: formData.get("bodyState"),
          eyeState: formData.get("eyeState"),
          primarySense: formData.get("primarySense"),
          durationMinutes: Number(formData.get("durationMinutes")),
          labelingMode: formData.get("labelingMode"),
          silenceProfile: formData.get("silenceProfile"),
          normalizationFrequency: formData.get("normalizationFrequency"),
          closingStyle: formData.get("closingStyle"),
          senseRotation: formData.get("senseRotation") || undefined,
          languages: [formData.get("language")],
          outputMode: formData.get("outputMode"),
        };
        const outputMode = formData.get("outputMode");
        const streamingEnabled = streamingInput.checked;

        submitButton.disabled = true;
        status.textContent = "Generating audio. This can take a few seconds.";

        const requestJson = async () => {
          const response = await fetch("/api/generate", {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
              Accept: "application/json",
            },
            body: JSON.stringify(payload),
          });

          if (!response.ok) {
            const errorBody = await response.json();
            throw new Error(errorBody?.error?.message || "The generator failed to respond.");
          }

          return response.json();
        };

        const requestStreamed = async () => {
          const response = await fetch("/api/generate", {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
              Accept: "text/event-stream",
            },
            body: JSON.stringify(payload),
          });

          if (!response.ok) {
            const errorContentType = response.headers.get("content-type") || "";
            if (errorContentType.includes("application/json")) {
              const errorBody = await response.json();
              throw new Error(errorBody?.error?.message || "The generator failed to respond.");
            }
            throw new Error(`The generator failed to respond. (${response.status})`);
          }

          if (!response.body) {
            throw new Error("Streaming updates are not available.");
          }

          const reader = response.body.getReader();
          const decoder = new TextDecoder();
          let buffer = "";
          let finalPayload = null;

          while (true) {
            const { value, done } = await reader.read();
            if (done) {
              break;
            }

            buffer += decoder.decode(value, { stream: true });
            let delimiterIndex = buffer.indexOf("\n\n");
            while (delimiterIndex !== -1) {
              const rawEvent = buffer.slice(0, delimiterIndex).trim();
              buffer = buffer.slice(delimiterIndex + 2);
              delimiterIndex = buffer.indexOf("\n\n");

              if (!rawEvent) {
                continue;
              }

              let eventType = "message";
              let data = "";
              for (const line of rawEvent.split("\n")) {
                if (line.startsWith("event:")) {
                  eventType = line.slice(6).trim();
                } else if (line.startsWith("data:")) {
                  data += line.slice(5).trim();
                }
              }

              if (eventType === "status") {
                addProgressStep(data);
                status.textContent = data;
              } else if (eventType === "done") {
                finalPayload = JSON.parse(data);
              } else if (eventType === "error") {
                throw new Error(data || "Streaming failed.");
              }
            }
          }

          if (!finalPayload) {
            throw new Error("The stream ended before returning a response.");
          }

          return finalPayload;
        };

        const requestAudio = async () => {
          const response = await fetch("/api/generate", {
            method: "POST",
            headers: {
              "Content-Type": "application/json",
              Accept: "audio/wav",
            },
            body: JSON.stringify(payload),
          });

          if (!response.ok) {
            const errorContentType = response.headers.get("content-type") || "";
            if (errorContentType.includes("application/json")) {
              const errorBody = await response.json();
              throw new Error(errorBody?.error?.message || "The generator failed to respond.");
            }
            throw new Error(`The generator failed to respond. (${response.status})`);
          }

          const audioBuffer = await response.arrayBuffer();
          const contentType = response.headers.get("content-type") || "audio/wav";
          return new Blob([audioBuffer], { type: contentType });
        };

        try {
          let script = "";
          let audioBlob = null;

          if (streamingEnabled) {
            const streamedResponse = await requestStreamed();
            script = streamedResponse?.script || "";
            if (streamedResponse?.audioBase64) {
              const binary = atob(streamedResponse.audioBase64);
              const bytes = new Uint8Array(binary.length);
              for (let index = 0; index < binary.length; index += 1) {
                bytes[index] = binary.charCodeAt(index);
              }
              audioBlob = new Blob([bytes], {
                type: streamedResponse?.audioContentType || "audio/wav",
              });
            }
          } else if (outputMode === "audio") {
            audioBlob = await requestAudio();
          } else {
            const jsonResponse = await requestJson();
            script = jsonResponse?.script || "";
            if (outputMode === "text-audio" && jsonResponse?.audioBase64) {
              const binary = atob(jsonResponse.audioBase64);
              const bytes = new Uint8Array(binary.length);
              for (let index = 0; index < binary.length; index += 1) {
                bytes[index] = binary.charCodeAt(index);
              }
              audioBlob = new Blob([bytes], {
                type: jsonResponse?.audioContentType || "audio/wav",
              });
            }
          }

          if (audioBlob) {
            currentUrl = URL.createObjectURL(audioBlob);
            audioPlayer.src = currentUrl;
            audioPlayer.hidden = false;
            downloadLink.href = currentUrl;
            downloadLink.hidden = false;
          } else {
            audioPlayer.hidden = true;
            downloadLink.hidden = true;
          }

          if (script) {
            scriptOutput.textContent = script;
            scriptOutput.hidden = false;
          } else {
            scriptOutput.hidden = true;
          }

          result.hidden = false;
          status.textContent = outputMode === "text" ? "Text ready!" : "Output ready!";
        } catch (err) {
          error.hidden = false;
          error.textContent = err instanceof Error ? err.message : "Something went wrong.";
          status.textContent = "";
        } finally {
          submitButton.disabled = false;
        }
      });
    </script>
  </body>
</html>
